! This file defines the format of rusEFI persistent configuration structure
! This file is processed by ../java_tools/config_definition.jar tool
! Comments start with '!'
!
! The format is unique to rusEFI but there is a guide to the format available in java_tools/config_definition/RusefiConfigGrammar.g4
!
! This file is used in combination with tunerstudio/tunerstudio.template.ini to generate the .ini files used by turner TunerStudio.
! The easiest way to find a specific variable within this config is to search within tunerstudio.template.ini for the on screen text from tuner studio
! this should provide the actual variable name, for example searching for "Number of Cylinders" will provide the variable "cylindersCount".
! Then you can search for "cylindersCount" in this file to find the definition.
!
! This file consists of two parts:
! The first part is engine_configuration_s area, followed by a few tuning tables.
!
! The only difference here is that engine_configuration_s area does not support hot modification while tuning tables can
! be modified without burning changes.
!
! See also tunerstudio/readme.md
!
! # Adding new fields
! The most important thing to note when adding fields is that if you change the offset
! of any other fields, users will have their configs scrambled when they update their firmware.
! As a result, this file is an organism that must be handled carefully. You may notice that
! there isn't much organization to this file with fields in amongst unrelated fields.
! That's OK, it's just a result of things being removed and new things being put in their
! places, and new things only being able to be added at the end of the structure or where
! other things were removed previously.
! Find a "padding" field (usually the huge mainUnusedEnd[] array at the end of the structure)
! The standard practice is to name these "unusedSomething", so you can find them easily
! by searching for "unused" within this file.
! Rename or substitute the field with any new fields that total to the same size.
! If you're adding a field to the end of the file, add it just before mainUnusedEnd[],
! and subtract the size of the field you added from mainUnusedEnd[].
! For example, if you added a uint8_t field, and mainUnusedEnd was `uint8_t[100]`,
! it should now be `uint8_t[99]`
! At this point it's a good idea to save your changes in version control, i.e. with `git commit`,
!	so that you can roll back to the current state after you generate the config files.
! This is important because we do not include the generated files in pull requests.
! We have a Github Actions workflow that generates all the files automatically after
! the pull request has been merged.
! Invoke gen_config.sh to generate .h and .ini files.
! Now check the `git diff` to make sure you haven't accidentally changed the offsets of
! any other fields.
! If you did, reset your version control state to your commit, i.e. with `git stash`,
! and fix the fields you created to make sure that they total the same size.
!
!
! each field is declared as
! type name;comment;"units",scale,offset,min,max,number_of_digits
! hello;I like rusEFI;"ms",1,0,-10,10,2
!
!
!
! Q: what's the difference between 'engineConfiguration' and rest of the 'persistent_config_s'?
! A: 'engineConfiguration' portion has 'activeConfiguration' copy so that we can detect changes
! todo: move all curves and tables out of engineConfiguration that would make 'activeConfiguration' smaller and we might save a couple of K of ram
!
!
!
! Q: What is "@OFFSET@"?
! A: That's a template placeholder for field offset within the resulting data structure.
!
! Q: What is "[0:2]"?
! A: That part of the bit declaration specified usage of three bits - from bit 0 to bit 2
!
! Q: how does 'custom' work?
! A: let's look at
!  #define can_baudrate_e_enum "100kbps", "250kbps", "500kbps", "1Mbps"
!   custom can_baudrate_e 1 bits, U08, @OFFSET@, [0:1], @@can_baudrate_e_enum@@
!   can_baudrate_e canBaudRate; set can_baudrate
!
! here #define XXX_enum defines enum options in a reusable way
! @@XXX_e_enum@@ is using the enum options defined above
!
! "custom NEW_TYPE_NAME 1 bits, U08, @OFFSET@, [0:1], @@can_baudrate_e_enum@@" defines NEW_TYPE_NAME
! and "can_baudrate_e canBaudRate; set can_baudrate" creates a parameter of that custom type "can_baudrate_e"
!
!
! bit bitName,"true value","false value";Tooltip text
!
!
! units,scale,offset,min,max,digits

!
! this is used to confirm that firmware and TunerStudio are using the same rusefi.ini version
! so not forget to change fileVersion in rusefi.ini
! todo: this not needed in light of TS_SIGNATURE but rusEFI console still uses it. Need to migrate
! rusEFI console from TS_FILE_VERSION to TS_SIGNATURE :(
#define TS_FILE_VERSION 20240610

! This is the version of the data stored in flash configuration
! Any time an incompatible change is made to the configuration format stored in flash,
! update this string to the current date! It is required to also update TS_SIGNATURE above
! when this happens.
#define FLASH_DATA_VERSION 20017

! this offset is part of console compatibility mechanism, please DO NOT change this offset
#define TS_FILE_VERSION_OFFSET 124

#define LOG_DELIMITER "`"

! all the sub-structures are going to be nested within the primary structure, that's
! needed to get a proper TunerStudio file

struct_no_prefix persistent_config_s

struct_no_prefix engine_configuration_s

#define BLOCKING_FACTOR 1320

#define SENT_INPUT_COUNT 1

#define LUA_PWM_COUNT 8
#define LUA_DIGITAL_INPUT_COUNT 8

! https://github.com/rusefi/rusefi/issues/2010 shows the corner case wheel with huge depth requirement
#define GAP_TRACKING_LENGTH 18

#define CONSOLE_DATA_PROTOCOL_TAG " @"
#define MAIN_HELP_URL "https://wiki.fome.tech/"

#define ETB_BIAS_CURVE_LENGTH 8

#define TOOTH_PACKET_COUNT 1000
#define TOOTH_PACKET_SIZE 2
#define TOOTH_DATA_LENGTH @@TOOTH_PACKET_SIZE@@*@@TOOTH_PACKET_COUNT@@

#define COMPOSITE_PACKET_SIZE 5

#define MAP_ANGLE_SIZE 8
#define MAP_WINDOW_SIZE 8

#define IAC_PID_MULT_SIZE 8

#define TORQUE_CURVE_SIZE 6
#define CLT_CURVE_SIZE 16
#define CLT_LIMITER_CURVE_SIZE 4
#define CRANKING_CLT_IDLE_CURVE_SIZE 8
#define CLT_CRANKING_CURVE_SIZE 8
#define IDLE_ADVANCE_CURVE_SIZE 8
#define CRANKING_ADVANCE_CURVE_SIZE 4

#define ENGINE_NOISE_CURVE_SIZE 16
#define CLT_TIMING_CURVE_SIZE 8
#define IDLE_VE_SIZE 4

#define TCU_SOLENOID_COUNT 6
#define TCU_GEAR_COUNT 10

! Matt says: The problem is the driver chip. Tle9201 can't do 20k. The drivers are too slow. On purpose to reduce EMI
#define ETB_HW_MAX_FREQUENCY 3000
#define ETB_COUNT 2
#define DC_PER_STEPPER 2

#define AUX_DIGITAL_VALVE_COUNT 2

#define IAT_CURVE_SIZE 16

#define VBAT_INJECTOR_CURVE_SIZE 8

#define DWELL_CURVE_SIZE 8

#define CRANKING_CURVE_SIZE 8

#define IGN_LOAD_COUNT 16
#define IGN_RPM_COUNT 16

#define MAX_CYLINDER_COUNT 12
#define HW_MAX_ADC_INDEX 17
#define TRIGGER_SIMULATOR_PIN_COUNT 2
#define TRIGGER_INPUT_PIN_COUNT 2
#define LOGIC_ANALYZER_CHANNEL_COUNT 4
#define SCRIPT_SETTING_COUNT 8

#define VEHICLE_INFO_SIZE 32

#define FUEL_RPM_COUNT 16
#define FUEL_LOAD_COUNT 16

#define BOOST_RPM_COUNT 8
#define BOOST_LOAD_COUNT 8
#define PEDAL_TO_TPS_SIZE 8
#define FUEL_LEVEL_TABLE_COUNT 8

#define STFT_CELL_COUNT 4
#define STFT_BANK_COUNT 2

#define CAN_DEFAULT_BASE 0x200

#define TRIGGERS_FILE_NAME "triggers.txt"
#define TRIGGER_IS_CRANK_KEY "crankBased"
#define TRIGGER_CYCLE_DURATION "cycleDuration"
#define TRIGGER_IS_SECOND_WHEEL_CAM "isSecondWheelCam"
#define TRIGGER_HAS_SECOND_CHANNEL "hasSecondChannel"
#define TRIGGER_HARDCODED_OPERATION_MODE "knownOperationMode"
#define TRIGGER_COMMENT "#"
#define TRIGGER_GAPS_COUNT "gapsCount"
#define TRIGGER_GAP_FROM "gapFrom"
#define TRIGGER_GAP_TO "gapTo"
#define TRIGGER_WITH_SYNC "isSynchronizationNeeded"

!
! all the xxx_PACKING_xxx constants are about persisting tables in compact for, for example packing RPM with 50 increment in a byte
! or packing numeric voltage inside an integer byte
!
! one byte RPM with '50' multiplier limits us at 12750 RPM which is below what small engines do
#define VOLTAGE_1_BYTE_PACKING_DIV 0.02
#define PERCENT_TRIM_BYTE_PACKING_DIV 0.02

#define SCRIPT_TABLE_8 8

#define SCRIPT_CURVE_8 8
#define SCRIPT_CURVE_16 16

#define TPS_TPS_ACCEL_TABLE 8
#define ADC_CHANNEL_NONE 0
#define TPS_TPS_ACCEL_CLT_CORR_TABLE 4

#define DFCO_RPM_MAP_TABLE 4

#define BARO_CORR_SIZE 4

#define MAF_DECODING_COUNT 64

#define GPPWM_LOAD_COUNT 8
#define GPPWM_RPM_COUNT 8
#define GPPWM_CHANNELS 4
#define GPPWM_NOTE_SIZE 16


struct stft_cell_cfg_s
	int8_t maxAdd;Maximum % of fuel possible for fuel trim to add while in this region.;"%", 1, 0, 0, 25, 0
	int8_t maxRemove;Maximum % of fuel possible for fuel trim to remove while in this region.;"%", 1, 0, -25, 0, 0
	uint16_t autoscale timeConstant;Time constant for correction while in this cell: this sets responsiveness of the closed loop correction. A value of 5.0 means it will try to make most of the correction within 5 seconds, and a value of 1.0 will try to correct within 1 second.;"sec", 0.1, 0, 0.1, 100, 2
end_struct

struct stft_s
	uint8_t autoscale maxIdleRegionRpm;Below this RPM, the idle region is active;"RPM", 50, 0, 0, 12000, 0
	uint8_t maxOverrunLoad;Below this engine load, the overrun region is active;"load", 1, 0, 0, 250, 0
	uint8_t minPowerLoad;Above this engine load, the power region is active;"load", 1, 0, 0, 250, 0
	uint8_t autoscale deadband;When close to correct AFR, pause correction. This can improve stability by not changing the adjustment if the error is extremely small, but is not required.;"%", 0.1, 0, 0, 3, 1

	int8_t minClt;Below this temperature, correction is disabled.;"C", 1, 0, -20, 100, 0
	uint8_t autoscale minAfr;Below this AFR, correction is paused;"afr", 0.1, 0, 10, 20, 1
	uint8_t autoscale maxAfr;Above this AFR, correction is paused;"afr", 0.1, 0, 10, 20, 1
	uint8_t startupDelay;Delay after starting the engine before beginning closed loop correction.;"seconds", 1, 0, 0, 250, 0

	stft_cell_cfg_s[STFT_CELL_COUNT iterate] cellCfgs;
end_struct

struct pid_s
	float pFactor;;"", 1, 0, -10000, 10000, 4
	float iFactor;;"", 1, 0, -10000, 10000, 4
	float dFactor;;"", 1, 0, -10000, 10000, 4
	int16_t offset;Linear addition to PID logic;"", 1, 0, -1000, 1000, 0
	int16_t periodMs;PID dTime;"ms", 1, 0, 0, 3000, 0
	int16_t minValue;Output Min Duty Cycle;"", 1, 0, -30000, 30000, 0
	int16_t maxValue;Output Max Duty Cycle;"", 1, 0, -30000, 30000, 0
end_struct

#define SentEtbType_enum "None", "GM type 1", "Ford type 1"
custom SentEtbType 1 bits, S08, @OFFSET@, [0:1], @@SentEtbType_enum@@

struct cranking_parameters_s
float baseFuel;Base mass of the per-cylinder fuel injected during cranking. This is then modified by the multipliers for CLT, IAT, TPS ect, to give the final cranking pulse width.\nA reasonable starting point is 60mg per liter per cylinder.\nex: 2 liter 4 cyl = 500cc/cyl, so 30mg cranking fuel.;"mg", 1, 0, 0, 500, 1
int16_t rpm;This sets the RPM limit below which the ECU will use cranking fuel and ignition logic, typically this is around 350-450rpm.;"RPM", 1, 0, 0, 3000, 0
end_struct

#define debug_mode_e_enum "INVALID", "TPS acceleration enrichment", "INVALID", "Stepper Idle Control", "Engine Load accl enrich", "Trigger Counters", "Soft Spark Cut", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "SD card", "sr5", "Knock", "INVALID", "Electronic Throttle", "Executor", "Bench Test / TS commands", "INVALID", "Analog inputs #1", "INVALID", "INVALID", "Status", "INVALID", "INVALID", "INVALID", "Metrics", "INVALID", "Ion Sense", "TLE8888", "Analog inputs #2", "INVALID", "INVALID", "INVALID", "Boost Control", "INVALID", "INVALID", "ETB Autotune", "Composite Log", "INVALID", "INVALID", "INVALID", "Dyno_View", "Logic_Analyzer", "INVALID", "TCU", "Lua"
custom debug_mode_e 1 bits, U08, @OFFSET@, [0:5], @@debug_mode_e_enum@@

#define vvt_mode_e_enum "Inactive", "Single Tooth", "Toyota 3 Tooth", "Miata NB2", "INVALID", "Bosch Quick Start", "4/1", "ST 170", "Ford Barra 3+1", "Nissan VQ", "Honda K Intake", "Nissan MR18", "Mitsu 3A92", "VTwin by MAP", "Mitsu 6G75", "Mazda Skyactiv", "Honda K Exhaust", "Mitsubishi 4G92/93/94", "Mitsubishi 4G63", "Mazda L"
custom vvt_mode_e 1 bits, U08, @OFFSET@, [0:5], @@vvt_mode_e_enum@@

! At the moment TIM1, TIM2, TIM3 and TIM9 are configured as ICU
! todo: as of ChibiOS3, only channels 1 & 2 are allowed to capture input, that's a ChibiOS driver limitation
! https://github.com/ChibiOS/ChibiOS-Drivers/blob/master/inc/timcap_driver.h is an alternative driver if channels 3 & 4 really become an issue
! todo: only one channel per timer is allowed for capture simultaneously, that's an STM32 limitation
! todo: convert slow ADC to software scheduler and make TIM8 available
! todo: maybe convert fast ADC to software scheduler as well? less sure about that

#define brain_input_pin_e_enum "NONE", "INVALID", "PA0", "PA1", "PA2", "PA3", "PA4", "PA5", "PA6", "PA7", "PA8", "PA9", "PA10", "PA11", "PA12", "PA13", "PA14", "PA15", "PB0", "PB1", "PB2", "PB3", "PB4", "PB5", "PB6", "PB7", "PB8", "PB9", "PB10", "PB11", "PB12", "PB13", "PB14", "PB15", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11", "PC12", "PC13", "PC14", "PC15", "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9", "PD10", "PD11", "PD12", "PD13", "PD14", "PD15", "PE0", "PE1", "PE2", "PE3", "PE4", "PE5", "PE6", "PE7", "PE8", "PE9", "PE10", "PE11", "PE12", "PE13", "PE14", "PE15", "PF0", "PF1", "PF2", "PF3", "PF4", "PF5", "PF6", "PF7", "PF8", "PF9", "PF10", "PF11", "PF12", "PF13", "PF14", "PF15", "PG0", "PG1", "PG2", "PG3", "PG4", "PG5", "PG6", "PG7", "PG8", "PG9", "PG10", "PG11", "PG12", "PG13", "PG14", "PG15", "PH0", "PH1", "PH2", "PH3", "PH4", "PH5", "PH6", "PH7", "PH8", "PH9", "PH10", "PH11", "PH12", "PH13", "PH14", "PH15", "PI0", "PI1", "PI2", "PI3", "PI4", "PI5", "PI6", "PI7", "PI8", "PI9", "PI10", "PI11", "PI12", "PI13", "PI14", "PI15"
custom brain_input_pin_e 2 bits, U16, @OFFSET@, [0:7], @@brain_input_pin_e_enum@@

!
! 'Gpio' is the most flexible kind of pin
! 'output_pin_e' is a brain pin known to be routed to control an output on your specific board
! 'brain_input_pin_e' is XXX
! 'switch_input_pin_e' is a slow digital input suitable for clutch or brake pedal switch but not suitable for VSS or Flex sensor input
!

#define Gpio_enum "NONE", "INVALID", "PA0", "PA1", "PA2", "PA3", "PA4", "PA5", "PA6", "PA7", "PA8", "PA9", "PA10", "PA11", "PA12", "PA13", "PA14", "PA15", "PB0", "PB1", "PB2", "PB3", "PB4", "PB5", "PB6", "PB7", "PB8", "PB9", "PB10", "PB11", "PB12", "PB13", "PB14", "PB15", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11", "PC12", "PC13", "PC14", "PC15", "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9", "PD10", "PD11", "PD12", "PD13", "PD14", "PD15", "PE0", "PE1", "PE2", "PE3", "PE4", "PE5", "PE6", "PE7", "PE8", "PE9", "PE10", "PE11", "PE12", "PE13", "PE14", "PE15", "PF0", "PF1", "PF2", "PF3", "PF4", "PF5", "PF6", "PF7", "PF8", "PF9", "PF10", "PF11", "PF12", "PF13", "PF14", "PF15", "PG0", "PG1", "PG2", "PG3", "PG4", "PG5", "PG6", "PG7", "PG8", "PG9", "PG10", "PG11", "PG12", "PG13", "PG14", "PG15", "PH0", "PH1", "PH2", "PH3", "PH4", "PH5", "PH6", "PH7", "PH8", "PH9", "PH10", "PH11", "PH12", "PH13", "PH14", "PH15", "PI0", "PI1", "PI2", "PI3", "PI4", "PI5", "PI6", "PI7", "PI8", "PI9", "PI10", "PI11", "PI12", "PI13", "PI14", "PI15"
#define switch_input_pin_e_enum "NONE", "INVALID", "PA0", "PA1", "PA2", "PA3", "PA4", "PA5", "PA6", "PA7", "PA8", "PA9", "PA10", "PA11", "PA12", "PA13", "PA14", "PA15", "PB0", "PB1", "PB2", "PB3", "PB4", "PB5", "PB6", "PB7", "PB8", "PB9", "PB10", "PB11", "PB12", "PB13", "PB14", "PB15", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11", "PC12", "PC13", "PC14", "PC15", "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9", "PD10", "PD11", "PD12", "PD13", "PD14", "PD15", "PE0", "PE1", "PE2", "PE3", "PE4", "PE5", "PE6", "PE7", "PE8", "PE9", "PE10", "PE11", "PE12", "PE13", "PE14", "PE15", "PF0", "PF1", "PF2", "PF3", "PF4", "PF5", "PF6", "PF7", "PF8", "PF9", "PF10", "PF11", "PF12", "PF13", "PF14", "PF15", "PG0", "PG1", "PG2", "PG3", "PG4", "PG5", "PG6", "PG7", "PG8", "PG9", "PG10", "PG11", "PG12", "PG13", "PG14", "PG15", "PH0", "PH1", "PH2", "PH3", "PH4", "PH5", "PH6", "PH7", "PH8", "PH9", "PH10", "PH11", "PH12", "PH13", "PH14", "PH15", "PI0", "PI1", "PI2", "PI3", "PI4", "PI5", "PI6", "PI7", "PI8", "PI9", "PI10", "PI11", "PI12", "PI13", "PI14", "PI15"

custom Gpio 2 bits, U16, @OFFSET@, [0:7], @@Gpio_enum@@
custom switch_input_pin_e 2 bits, U16, @OFFSET@, [0:7], @@switch_input_pin_e_enum@@

#define output_pin_e_enum "NONE", "INVALID", "PA0", "PA1", "PA2", "PA3", "PA4", "PA5", "PA6", "PA7", "PA8", "PA9", "PA10", "PA11", "PA12", "PA13", "PA14", "PA15", "PB0", "PB1", "PB2", "PB3", "PB4", "PB5", "PB6", "PB7", "PB8", "PB9", "PB10", "PB11", "PB12", "PB13", "PB14", "PB15", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11", "PC12", "PC13", "PC14", "PC15", "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9", "PD10", "PD11", "PD12", "PD13", "PD14", "PD15", "PE0", "PE1", "PE2", "PE3", "PE4", "PE5", "PE6", "PE7", "PE8", "PE9", "PE10", "PE11", "PE12", "PE13", "PE14", "PE15", "PF0", "PF1", "PF2", "PF3", "PF4", "PF5", "PF6", "PF7", "PF8", "PF9", "PF10", "PF11", "PF12", "PF13", "PF14", "PF15", "PG0", "PG1", "PG2", "PG3", "PG4", "PG5", "PG6", "PG7", "PG8", "PG9", "PG10", "PG11", "PG12", "PG13", "PG14", "PG15", "PH0", "PH1", "PH2", "PH3", "PH4", "PH5", "PH6", "PH7", "PH8", "PH9", "PH10", "PH11", "PH12", "PH13", "PH14", "PH15", "PI0", "PI1", "PI2", "PI3", "PI4", "PI5", "PI6", "PI7", "PI8", "PI9", "PI10", "PI11", "PI12", "PI13", "PI14", "PI15", "MC33972_1", "MC33972_2", "MC33972_3", "MC33972_4", "MC33972_5", "MC33972_6", "MC33972_7", "MC33972_8", "MC33972_9", "MC33972_10", "MC33972_11", "MC33972_12", "MC33972_13", "MC33972_14", "MC33972_15", "MC33972_16", "MC33972_17", "MC33972_18", "MC33972_19", "MC33972_20", "MC33972_21", "MC33972_22", "TLE8888_1", "TLE8888_2", "TLE8888_3", "TLE8888_4", "TLE8888_5", "TLE8888_6", "TLE8888_7", "TLE8888_8", "TLE8888_9", "TLE8888_10", "TLE8888_11", "TLE8888_12", "TLE8888_13", "TLE8888_14", "TLE8888_15", "TLE8888_16", "TLE8888_17", "TLE8888_18", "TLE8888_19", "TLE8888_20", "TLE8888_21", "TLE8888_22", "TLE8888_23", "TLE8888_24", "TLE8888_25", "TLE8888_26", "TLE8888_27", "TLE8888_28", "INVALID", "INVALID", "INVALID", "TLE6240_1", "TLE6240_2", "TLE6240_3", "TLE6240_4", "TLE6240_5", "TLE6240_6", "TLE6240_7", "TLE6240_8", "TLE6240_9", "TLE6240_10", "TLE6240_11", "TLE6240_12", "TLE6240_13", "TLE6240_14", "TLE6240_15", "TLE6240_16"
custom output_pin_e 2 bits, U16, @OFFSET@, [0:7], @@output_pin_e_enum@@

#define pin_output_mode_e_enum "default", "default inverted", "open collector", "open collector inverted"
custom pin_output_mode_e 1 bits, U08, @OFFSET@, [0:1], @@pin_output_mode_e_enum@@

#define pin_input_mode_e_enum "DEFAULT", "PULLUP", "PULLDOWN"
custom pin_input_mode_e 1 bits, U08,	@OFFSET@,	[0:1], @@pin_input_mode_e_enum@@

#define gppwm_channel_e_enum "Zero", "TPS", "MAP", "CLT", "IAT", "Fuel Load", "Ignition Load", "Aux Temp 1", "Aux Temp 2", "Accel Pedal", "Battery Voltage", "VVT 1 I", "VVT 1 E", "VVT 2 I", "VVT 2 E", "Ethanol (Flex) %", "Aux Linear 1", "Aux Linear 2", "GPPWM Output 1", "GPPWM Output 2", "GPPWM Output 3", "GPPWM Output 4", "Lua Gauge 1", "Lua Gauge 2", "RPM", "Gear (detected)", "Baro pressure", "EGT 1", "EGT 2", "Aux Linear 3", "Aux Linear 4", "Vehicle speed"
custom gppwm_channel_e 1 bits, U08, @OFFSET@, [0:4], @@gppwm_channel_e_enum@@

struct gppwm_channel
	output_pin_e pin;Select a pin to use for PWM or on-off output.;
	uint8_t dutyIfError;If an error (with a sensor, etc) is detected, this value is used instead of reading from the table.\nThis should be a safe value for whatever hardware is connected to prevent damage.;"%", 1, 0, 0, 100, 0
	uint16_t pwmFrequency;Select a frequency to run PWM at.\nSet this to 0hz to enable on-off mode.;"hz", 1, 0, 0, 500, 0

	uint8_t onAboveDuty;Hysteresis: in on-off mode, turn the output on when the table value is above this duty.;"%", 1, 0, 0, 100, 0
	uint8_t offBelowDuty;Hysteresis: in on-off mode, turn the output off when the table value is below this duty.;"%", 1, 0, 0, 100, 0

	gppwm_channel_e loadAxis;Selects the Y axis to use for the table.;
	gppwm_channel_e rpmAxis;Selects the X axis to use for the table.;

	int16_t[GPPWM_LOAD_COUNT] autoscale loadBins;;"load", 0.1, 0, -1000, 1000, 1
	int16_t[GPPWM_RPM_COUNT] rpmBins;;"RPM", 1, 0, -30000, 30000, 0
	uint8_t[GPPWM_RPM_COUNT x GPPWM_LOAD_COUNT] autoscale table;;"duty", 0.5, 0, 0, 100, 1
end_struct

custom air_pressure_sensor_type_e 1 bits, U08, @OFFSET@, [0:4], "Custom", "DENSO183", "MPX4250", "HONDA3BAR", "NEON_2003", "22012AA090", "GM 3 Bar", "MPX4100", "Toyota 89420-02010", "MPX4250A", "Bosch 2.5", "Mazda1Bar", "GM 2 Bar", "GM 1 Bar", "MPXH6400"

!
! lower 16 values are used on stm32 FOME, values above 16 are related to Kinetis work in progress
!
#define adc_channel_e_enum "Disabled", "PA0", "PA1", "PA2", "PA3", "PA4", "PA5", "PA6", "PA7", "PB0", "PB1", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5"
custom adc_channel_e 1 bits, U08, @OFFSET@, [0:5], @@adc_channel_e_enum@@

struct air_pressure_sensor_config_s
float lowValue;kPa value at low volts;"kpa", 1, 0, -400, 800, 2
float highValue;kPa value at high volts;"kpa", 1, 0, -400, 800, 2
air_pressure_sensor_type_e type;
adc_channel_e hwChannel;

end_struct

struct MAP_sensor_config_s
float[MAP_ANGLE_SIZE] samplingAngleBins;;"", 1, 0, 0, 18000, 2
float[MAP_ANGLE_SIZE] samplingAngle;MAP averaging sampling start crank degree angle;"deg", 1, 0, -720, 720, 2
float[MAP_WINDOW_SIZE] samplingWindowBins;;"", 1, 0, 0, 18000, 2
float[MAP_WINDOW_SIZE] samplingWindow;MAP averaging angle crank degree duration;"deg", 1, 0, -720, 720, 2
air_pressure_sensor_config_s sensor
end_struct

struct_no_prefix thermistor_conf_s
	int autoscale tempC_1;Temperature 1;"deg C", 0.01, 0, -40, 200, 1
	int autoscale tempC_2;Temperature 2, must be > Temperature 1;"deg C", 0.01, 0, -40, 200, 1
	int autoscale tempC_3;Temperature 3, must be > Temperature 2;"deg C", 0.01, 0, -40, 200, 1
	uint32_t autoscale resistance_1;Sensor resistance while at temperature 1;"Ohm", 0.01, 0, 0, 200000, 1
	uint32_t autoscale resistance_2;Sensor resistance while at temperature 2;"Ohm", 0.01, 0, 0, 200000, 1
	uint32_t autoscale resistance_3;Sensor resistance while at temperature 3;"Ohm", 0.01, 0, 0, 200000, 1

	uint32_t autoscale bias_resistor;Pull-up resistor value on your board;"Ohm", 0.1, 0, 0, 200000, 1
end_struct

struct linear_sensor_s
	adc_channel_e hwChannel;
	float v1;;"volts", 1, 0, 0, 10, 2
	float value1;;"kPa", 1, 0, -100000, 100000, 2
	float v2;;"volts", 1, 0, 0, 10, 2
	float value2;;"kPa", 1, 0, -100000, 100000, 2
end_struct

struct ThermistorConf
	thermistor_conf_s config;
	adc_channel_e adcChannel;
end_struct

custom engine_type_e 4 bits, S32, @OFFSET@, [0:6], @@engine_type_e_auto_enum@@
engine_type_e engineType;http://rusefi.com/wiki/index.php?title=Manual:Engine_Type

uint16_t sensorSnifferRpmThreshold;Disable sensor sniffer above this rpm;"RPM", 1, 0, 0, 10000, 0
uint16_t launchRpm;A secondary Rev limit engaged by the driver to help launch the vehicle faster;"rpm", 1, 0, 0, 20000, 0
uint16_t rpmHardLimit;Hard cut above this RPM. Set slightly lower than absolute maximum RPM - may overshoot slightly.;"rpm", 1, 0, 0, 20000, 0
uint16_t engineSnifferRpmThreshold;Engine sniffer would be disabled above this rpm;"RPM", 1, 0, 0, 30000, 0

	uint8_t autoscale multisparkMaxRpm;Disable multispark above this engine speed.;"rpm", 50, 0, 0, 3000, 0
	uint8_t autoscale maxAcRpm;Above this RPM, disable AC. Set to 0 to disable check.;"rpm", 50, 0, 0, 10000, 0
	uint8_t maxAcTps;Above this TPS, disable AC. Set to 0 to disable check.;"%", 1, 0, 0, 100, 0
	uint8_t maxAcClt;Above this CLT, disable AC to prevent overheating the engine. Set to 0 to disable check.;"deg C", 1, 0, 0, 150, 0

	uint8_t multisparkMaxSparkingAngle;This parameter sets the latest that the last multispark can occur after the main ignition event. For example, if the ignition timing is 30 degrees BTDC, and this parameter is set to 45, no multispark will ever be fired after 15 degrees ATDC.;"deg", 1, 0, 0, 60, 0
	uint8_t multisparkMaxExtraSparkCount;Configures the maximum number of extra sparks to fire (does not include main spark);"count", 1, 0, 1, 5, 0

custom ignition_mode_e 1 bits, U08, @OFFSET@, [0:1], "Single Coil", "Individual Coils", "Wasted Spark", "Two Distributors"
ignition_mode_e ignitionMode;Single coil = distributor\nIndividual coils = one coil per cylinder (COP, coil-near-plug), requires sequential mode\nWasted spark = Fires pairs of cylinders together, either one coil per pair of cylinders or one coil per cylinder\nTwo distributors = A pair of distributors, found on some BMW, Toyota and other engines

custom can_nbc_e 1 bits, U08, @OFFSET@, [0:4], "None", "FIAT", "VAG", "MAZDA RX8", "BMW", "W202", "BMW E90", "Haltech", "VAG MQB", "Nissan VQ35", "Genesis Coupe", "Honda K", "AiM", "type 13", "type 14"
can_nbc_e canNbcType

struct injector_s
	float flow;This is your injector flow at the fuel pressure used in the vehicle.;"", 1, 0, 0, 99999, 2
	uint16_t[VBAT_INJECTOR_CURVE_SIZE] autoscale battLagCorrBins;;"volts", 0.01, 0, 0, 20, 2
	uint16_t[VBAT_INJECTOR_CURVE_SIZE] autoscale battLagCorr;ms delay between injector open and close dead times;"ms", 0.01, 0, 0, 50, 2
end_struct

injector_s injector
injector_s injectorSecondary

bit isForcedInduction;Does the vehicle have a turbo or supercharger?
bit unusedFordTps
bit lambdaProtectionEnable
bit overrideTriggerGaps
bit enableFan1WithAc;Turn on this fan when AC is on.
bit enableFan2WithAc;Turn on this fan when AC is on.
bit disableFan1WhenStopped;Inhibit operation of this fan while the engine is not running.
bit disableFan2WhenStopped;Inhibit operation of this fan while the engine is not running.
bit enableTrailingSparks;Enable secondary spark outputs that fire after the primary (rotaries, twin plug engines).
bit etb_use_two_wires;TLE7209 uses two-wire mode. TLE9201 and VNH2SP30 do NOT use two wire mode.
bit isDoubleSolenoidIdle;Subaru/BMW style where default valve position is somewhere in the middle. First solenoid opens it more while second can close it more than default position.
bit enableStagedInjection
bit useTLE8888_cranking_hack;
bit kickStartCranking;Experimental kick start cranking mode
bit useSeparateIdleTablesForCrankingTaper;This uses separate ignition timing and VE tables not only for idle conditions, also during the postcranking-to-idle taper transition (See also afterCrankingIACtaperDuration).
bit launchControlEnabled;
bit doNotFilterTriggerEdgeNoise,"without filter","with filter";"Detect double trigger edges"
bit antiLagEnabled;
bit useRunningMathForCranking,"Fuel Map","Fixed";For cranking either use the specified fixed base fuel mass, or use the normal running math (VE table).
bit useTLE8888_stepper
bit usescriptTableForCanSniffingFiltering
bit verboseCan,"Print all","Do not print";Print incoming and outgoing first bus CAN messages in FOME console
bit artificialTestMisfire,"Danger Mode","No thank you";Experimental setting that will cause a misfire\nDO NOT ENABLE.
bit unusedFordPps
bit cltSensorPulldown
bit iatSensorPulldown
bit allowIdenticalPps
bit is_enabled_spi_5
bit is_enabled_spi_6

int16_t tpsMin;Closed throttle, 1 volt = 200 units;"ADC", 1, 0, 0, 1023, 0
int16_t tpsMax;Full throttle, 1 volt = 200 units;"ADC", 1, 0, 0, 1023, 0

int16_t tpsErrorDetectionTooLow;Minimum allowed position for throttle and accelerator position sensors. Beyond this value, the sensor will register an error.;"%", 1, 0, -10, 0, 0
int16_t tpsErrorDetectionTooHigh;Maximum allowed position for throttle and accelerator position sensors. Beyond this value, the sensor will register an error.;"%", 1, 0, 100, 110, 0

cranking_parameters_s cranking
	float ignitionDwellForCrankingMs;Dwell duration while cranking;"ms", 1, 0, 0, 200, 1
	uint16_t etbRevLimitStart;Once engine speed passes this value, start reducing ETB angle.;"rpm", 1, 0, 0, 15000, 0
	uint16_t etbRevLimitRange;This far above 'Soft limiter start', fully close the throttle. At the bottom of the range, throttle control is normal. At the top of the range, the throttle is fully closed.;"rpm", 1, 0, 0, 2000, 0

MAP_sensor_config_s map


ThermistorConf clt;todo: merge with channel settings, use full-scale Thermistor here!
ThermistorConf iat;
	
	int launchTimingRetard;;"deg", 1, 0, -180, 180, 2
	float knockBandCustom;Knock filter center frequency override. By default, this is calculated from your cylinder bore. Set this to non-zero to override.;"kHz", 1, 0, 0, 20, 2

uint16_t autoscale displacement;Engine displacement in litres;"L", 0.001, 0, 0, 65, 3

uint16_t triggerSimulatorRpm;;"RPM", 1, 0, 0, 30000, 0

uint32_t cylindersCount;Number of cylinder the engine has.;"", 1, 0, 1, @@MAX_CYLINDER_COUNT@@, 0

! see firing_order.h
! FO_1 = 0
! FO_1_3_2_4 = 3
! FO_1_8_4_3_6_5_7_2 = 5
! FO_1_2_4_5_3 = 6

custom firing_order_e 1 bits, U08, @OFFSET@, [0:5], "One Cylinder", "1-3-4-2", "1-2-4-3", "1-3-2-4", "1-5-3-6-2-4", "1-8-4-3-6-5-7-2", "1-2-4-5-3", "1-4-2-5-3-6", "1-2", "1-2-3-4-5-6", "1-2-3", "1-8-7-2-6-5-4-3", "1-5-4-2-6-3-7-8", "1-6-3-2-5-4", "1-10-9-4-3-6-5-8-7_2", "1-7-5-11-3-9-6-12-2-8-4-10", "1-7-4-10-2-8-6-12-3-9-5-11", "1-4-3-2", "1-12-5-8-3-10-6-7-2-11-4-9", "1-2-7-8-4-5-6-3", "1-3-7-2-6-5-4-8", "1-2-3-4-5-6-7-8-9", "INVALID", "1-2-3-4-5-6-7-8-9-10-11-12", "1-3-2", "1-2-3-4-5-6-7-8", "1-5-4-8-6-3-7-2", "1-4-3-6-2-5", "1-8-7-3-6-5-4-2", "1-6-2-4-3-5", "1-6-5-4-3-2", "1-4-5-2-3-6", "1-5-4-8-3-7-2-6", "1-6-5-10-2-7-3-8-4-9"
firing_order_e firingOrder;

uint8_t vvtBumpAmount;;"deg", 1, 0, -30, 30, 0
uint16_t autoscale benchTestOnTime;Duration of each test pulse;"ms", 0.01, 0, 0, 500, 2

float cylinderBore;Cylinder diameter in mm.;"mm", 1, 0, 0, 20000, 2

#define engine_load_mode_e_enum "Speed Density", "MAF Air Charge", "Alpha-N", "Lua"


custom engine_load_mode_e 1 bits, U08, @OFFSET@, [0:2], @@engine_load_mode_e_enum@@
engine_load_mode_e fuelAlgorithm;This setting controls which fuel quantity control algorithm is used.\nAlpha-N means drive by TPS commonly only used for NA engines\nSpeed Density requires MAP sensor and is the default choice for may installs\nMAF air charge is a cylinder filling based method that uses a mass air flow sensor.;
uint8_t ALSMaxTPS;;"%", 1, 0, 0, 10, 0

Gpio binarySerialTxPin
Gpio binarySerialRxPin

custom injection_mode_e 1 bits, U08, @OFFSET@, [0:1], "Simultaneous", "Sequential", "Batch", "Single Point"
injection_mode_e crankingInjectionMode;This is the injection strategy during engine start. See Fuel/Injection settings for more detail. It is suggested to use "Simultaneous".

injection_mode_e injectionMode;This is where the fuel injection type is defined: "Simultaneous" means all injectors will fire together at once. "Sequential" fires the injectors on a per cylinder basis, which requires individually wired injectors. "Batched" will fire the injectors in groups. If your injectors are individually wired you will also need to enable "Two wire batch emulation".

uint16_t boostControlMinRpm; Minimum RPM to enable boost control. Use this to avoid solenoid noise at idle, and help spool in some cases.;"", 1, 0, 0, 25000, 0
uint8_t boostControlMinTps; Minimum TPS to enable boost control. Use this to avoid solenoid noise at idle, and help spool in some cases.;"", 1, 0, 0, 100, 0
uint8_t boostControlMinMap; Minimum MAP to enable boost control. Use this to avoid solenoid noise at idle, and help spool in some cases.;"", 1, 0, 0, 250, 0

custom timing_mode_e 1 bits, U08, @OFFSET@, [0:0], "dynamic", "fixed"
timing_mode_e timingMode;Dynamic uses the timing map to decide the ignition timing, Static timing fixes the timing to the value set below (only use for checking static timing with a timing light).

adc_channel_e mafAdcChannel

uint16_t benchTestCount;How many test bench pulses do you want;"", 1, 0, 0, 10000, 0

angle_t crankingTimingAngle;Ignition advance angle used during engine cranking, 5-10 degrees will work as a base setting for most engines.\nThere is tapering towards running timing advance;"deg", 1, 0, -30, 30, 0

int8_t gapTrackingLengthOverride;How many consecutive gap rations have to match expected ranges for sync to happen;"count", 1, 0, 1, @@GAP_TRACKING_LENGTH@@, 0
 uint8_t maxIdleVss;Above this speed, disable closed loop idle control. Set to 0 to disable (allow closed loop idle at any speed).;"kph", 1, 0, 0, 100, 0
 uint16_t minOilPressureAfterStart;Expected oil pressure after starting the engine. If oil pressure does not reach this level within 5 seconds of engine start, fuel will be cut. Set to 0 to disable and always allow starting.;"kPa", 1, 0, 0, 1000, 0

angle_t fixedModeTiming;This value is the ignition timing used when in 'fixed timing' mode, i.e. constant timing\nThis mode is useful when adjusting distributor location.;"RPM", 1, 0, 0, 3000, 0

angle_t globalTriggerAngleOffset;Angle between Top Dead Center (TDC) and the first trigger event.\nPositive value in case of synchronization point before TDC and negative in case of synchronization point after TDC\n.Knowing this angle allows us to control timing and other angles in reference to TDC.;"deg btdc", 1, 0, -720, 720, 0



float analogInputDividerCoefficient;Ratio/coefficient of input voltage dividers on your PCB. For example, use '2' if your board divides 5v into 2.5v. Use '1.66' if your board divides 5v into 3v.;"coef", 1, 0, 0.01, 10, 2
float vbattDividerCoeff;This is the ratio of the resistors for the battery voltage, measure the voltage at the battery and then adjust this number until the gauge matches the reading.;"coef", 1, 0, 0.01, 99, 2

uint8_t fanOnTemperature;Cooling fan turn-on temperature threshold, in Celsius;"deg C", 1, 0, 0, 150, 0
uint8_t fanOffTemperature;Cooling fan turn-off temperature threshold, in Celsius;"deg C", 1, 0, 0, 150, 0

output_pin_e acrPin;

float driveWheelRevPerKm;Number of revolutions per kilometer for the wheels your vehicle speed sensor is connected to. Use an online calculator to determine this based on your tire size.;"revs/km", 1, 0, 100, 1000, 1

int canSleepPeriodMs;CANbus thread period in ms;"ms", 1, 0, 0, 1000, 2
	int byFirmwareVersion;;"index", 1, 0, 0, 300, 0

	adc_channel_e tps1_1AdcChannel;First throttle body, first sensor
adc_channel_e vbattAdcChannel;This is the processor input pin that the battery voltage circuit is connected to, if you are unsure of what pin to use, check the schematic that corresponds to your PCB.
adc_channel_e fuelLevelSensor;This is the processor pin that your fuel level sensor in connected to. This is a non standard input so will need to be user defined.
	adc_channel_e tps2_1AdcChannel;Second throttle body, first sensor


	float idle_derivativeFilterLoss;0.1 is a good default value;"x", 1, 0, -1000000, 1000000, 4
	int trailingSparkAngle;just a temporary solution;"angle", 1, 0, 0, 720, 0

struct trigger_config_s

#define trigger_type_e_enum "custom toothed wheel", "Ford Aspire", "Dodge Neon 1995", "Miata NA", "Mitsubishi Mess 4", "GM_7X", "Cooper R50", "Mazda SOHC 4", "60/2", "36/1", "Mercedes Two Segment", "Mitsubishi 4G93 11", "EZ30", "INVALID", "Dodge Neon 2003", "Mazda DOHC 1+4", "1+1", "INVALID", "Single Tooth", "Dodge Ram 1+16", "60/2 VW", "Benelli Tre", "Dodge Stratus", "36_2_2_2", "Nissan Primera", "dev 2JZ 3/34 simulator", "Rover K", "GM 24x 5 degree", "Honda CBR 600", "Mitsubishi 4G92/93/94 Cam 29", "Honda CBR 600 custom", "3/1 skipped", "Dodge Neon 2003 crank", "Miata NB", "Mitsubishi 4G63 Cam 34", "INVALID", "Subaru 7+6", "Jeep 18-2-2-2", "12 tooth crank", "Dodge Neon 1995 crank only", "Jeep XJ 4 cyl", "FiatIAQ_P8", "Mazda Z5", "INVALID", "Renix 44-2-2", "Renix 66-2-2-2", "Honda K 12+1", "INVALID", "36/2", "Subaru SVX", "1+16", "Subaru 7 without 6", "INVALID", "TriTach", "GM 60/2/2/2", "Skoda Favorit", "Barra 3+1 Cam", "Kawa KX450F", "Nissan VQ35", "INVALID", "Nissan VQ30", "Nissan QR25", "Mitsubishi 3A92", "Subaru SVX Crank 1", "Subaru SVX Cam VVT", "Ford PIP", "Suzuki G13B", "Honda K 4+1", "Nissan MR18 Crank", "32/2", "36-2-1", "36-2-1-1", "INVALID", "INVALID", "GM 24x 3 degree", "INVALID", "trg76"

custom trigger_type_e 4 bits, U32, @OFFSET@, [0:6], @@trigger_type_e_enum@@
	trigger_type_e type;https://github.com/rusefi/rusefi/wiki/All-Supported-Triggers
	int customTotalToothCount;;"number", 1, 0, 1, 300, 0
	int customSkippedToothCount;;"number", 1, 0, 0, 300, 0
end_struct

trigger_config_s trigger;

    float airByRpmTaper;Extra air taper amount;"%", 1, 0, 0, 50, 1

custom spi_device_e 1 bits, U08, @OFFSET@, [0:2], "Off", "SPI1", "SPI2", "SPI3", "SPI4", "SPI5", "SPI6"
	uint8_t boostControlSafeDutyCycle;Duty cycle to use in case of a sensor failure. This duty cycle should produce the minimum possible amount of boost. This duty is also used in case any of the minimum RPM/TPS/MAP conditions are not met.;"%", 1, 0, 0, 100, 0

adc_channel_e throttlePedalPositionAdcChannel;Throttle pedal position first channel
	pin_output_mode_e tle6240_csPinMode;

	uint8_t acrRevolutions;;"", 1, 0, 0, 10, 0

float globalFuelCorrection;;"coef", 1, 0, 0, 1000, 2

	float adcVcc;;"volts", 1, 0, 0, 6, 3
	float mapCamDetectionAnglePosition;;"Deg", 1, 0, 0, 360, 0
	brain_input_pin_e[CAM_INPUTS_COUNT iterate] camInputs;Camshaft input could be used either just for engine phase detection if your trigger shape does not include cam sensor as 'primary' channel, or it could be used for Variable Valve timing on one of the camshafts.
	
struct afr_sensor_s
	adc_channel_e hwChannel;
	adc_channel_e hwChannel2;
	uint16_t autoscale v1;;"volts", 0.001, 0, 0, 10, 3
	uint16_t autoscale value1;;"AFR", 0.001, 0, 0, 50, 2
	uint16_t autoscale v2;;"volts", 0.001, 0, 0, 10, 3
	uint16_t autoscale value2;;"AFR", 0.001, 0, 0, 50, 2
end_struct

afr_sensor_s afr

	Gpio tle6240_cs;

switch_input_pin_e throttlePedalUpPin;Throttle Pedal not pressed switch - used on some older vehicles like early Mazda Miata


air_pressure_sensor_config_s baroSensor

struct idle_hardware_s
	int solenoidFrequency;;"Hz", 1, 0, 0, 3000, 0

	output_pin_e solenoidPin
	Gpio stepperDirectionPin
	Gpio stepperStepPin
	pin_output_mode_e solenoidPinMode
end_struct

struct dc_io
	Gpio directionPin1;
	Gpio directionPin2;
	Gpio controlPin;Acts as EN pin in two-wire mode
	Gpio disablePin;
end_struct
	
	idle_hardware_s idle;

	float manIdlePosition;Base idle valve position, 0 to 100%. This is typically set to provide an idle speed slightly above the target RPM when the engine is fully warmed up.;"%", 1, 0, 0, 100, 0

uint8_t autoscale knockRetardAggression;Ignition timing to remove when a knock event occurs. Advice: 5% (mild), 10% (turbo/high comp.), 15% (high knock, e.g. GDI), 20% (spicy lump),;"%", 0.1, 0, 0, 20, 1
uint8_t autoscale knockRetardReapplyRate;After a knock event, reapply timing at this rate.;"deg/s", 0.1, 0, 0, 10, 1

#define engineSyncCam_enum "Intake First Bank", "Exhaust First Bank", "Intake Second Bank", "Exhaust Second Bank"
custom engineSyncCam_e 1 bits, S08, @OFFSET@, [0:1], @@engineSyncCam_enum@@
engineSyncCam_e engineSyncCam;Select which cam is used for engine sync. Other cams will be used only for VVT measurement, but not engine sync.

	uint8_t vssFilterReciprocal;Set this so your vehicle speed signal is responsive, but not noisy. Larger value give smoother but slower response.;"", 1, 0, 2, 200, 0

	uint16_t autoscale vssGearRatio;Number of turns of your vehicle speed sensor per turn of the wheels. For example if your sensor is on the transmission output, enter your axle/differential ratio. If you are using a hub-mounted sensor, enter a value of 1.0.;"ratio", 0.001, 0, 0, 60, 3
	uint8_t vssToothCount;Number of pulses output per revolution of the shaft where your VSS is mounted. For example, GM applications of the T56 output 17 pulses per revolution of the transmission output shaft.;"count", 1, 0, 1, 100, 0

	#define ve_override_e_enum "None", "MAP", "TPS"
	custom ve_override_e 1 bits, U08, @OFFSET@, [0:1], @@ve_override_e_enum@@

	ve_override_e idleVeOverrideMode;Override the Y axis (load) value used for only the Idle VE table.\nAdvanced users only: If you aren't sure you need this, you probably don't need this.

	Gpio l9779_cs;

	output_pin_e o2heaterPin;On-off O2 sensor heater control. 'ON' if engine is running, 'OFF' if stopped or cranking.

	output_pin_e[MAX_CYLINDER_COUNT iterate] injectionPins;
	output_pin_e[MAX_CYLINDER_COUNT iterate] injectionPinsStage2;
	output_pin_e[MAX_CYLINDER_COUNT iterate] ignitionPins;

	pin_output_mode_e injectionPinMode;
	pin_output_mode_e ignitionPinMode;

	output_pin_e fuelPumpPin;
	pin_output_mode_e fuelPumpPinMode;

	adc_channel_e throttlePedalPositionSecondAdcChannel;Throttle pedal, secondary channel.

	output_pin_e malfunctionIndicatorPin;Check engine light, also malfunction indicator light. Always blinks once on boot.
	pin_output_mode_e malfunctionIndicatorPinMode;
	pin_output_mode_e fanPinMode;
	output_pin_e fanPin;

switch_input_pin_e clutchDownPin;Some cars have a switch to indicate that clutch pedal is all the way down
	output_pin_e alternatorControlPin;
	pin_output_mode_e alternatorControlPinMode;
	pin_input_mode_e clutchDownPinMode;

	pin_output_mode_e electronicThrottlePin1Mode;
	spi_device_e max31855spiDevice;
	Gpio debugTriggerSync;
	Gpio mc33972_cs;
	pin_output_mode_e mc33972_csPinMode;

	adc_channel_e auxFastSensor1_adcChannel;Useful in Research&Development phase
	adc_channel_e tps1_2AdcChannel;First throttle body, second sensor.
	adc_channel_e tps2_2AdcChannel;Second throttle body, second sensor.

	float idle_antiwindupFreq;0.1 is a good default value;"x", 1, 0, -1000000, 1000000, 4

	brain_input_pin_e[TRIGGER_INPUT_PIN_COUNT iterate] triggerInputPins;
	uint16_t mc33_t_min_boost;Minimum allowed time for the boost phase. If the boost target current is reached before this time elapses, it is assumed that the injector has failed short circuit.;"us", 1, 0, 0, 10000, 0
	output_pin_e tachOutputPin;
	pin_output_mode_e tachOutputPinMode;

	adc_channel_e maf2AdcChannel

	output_pin_e mainRelayPin;
	Gpio sdCardCsPin;
	Gpio canTxPin;set_can_tx_pin X
	Gpio canRxPin;set_can_rx_pin X

pin_input_mode_e throttlePedalUpPinMode;
	uint8_t acIdleExtraOffset;Additional idle % while A/C is active;"%", 1, 0, 0, 100, 0

    uint16_t autoscale finalGearRatio;Ratio between the wheels and your transmission output. ;"ratio", 0.01, 0, 0, 10, 2

	brain_input_pin_e tcuInputSpeedSensorPin
	uint8_t tcuInputSpeedSensorTeeth

	pin_output_mode_e mainRelayPinMode;

	uint16_t wastegatePositionMin;Voltage when the wastegate is closed.\nYou probably don't have one of these!;"mv", 1, 0, 0, 5000, 0
	uint16_t wastegatePositionMax;Voltage when the wastegate is fully open.\nYou probably don't have one of these!\n1 volt = 1000 units;"mv", 1, 0, 0, 5000, 0

	output_pin_e secondSolenoidPin;Some Subaru and some Mazda use double-solenoid idle air valve

	uint32_t tunerStudioSerialSpeed;Secondary TTL channel baud rate;"BPs", 1, 0, 0, 1000000, 0

	float compressionRatio;For reference, not used by the ECU.;"CR", 1, 0, 0, 300, 1

	Gpio[TRIGGER_SIMULATOR_PIN_COUNT iterate] triggerSimulatorPins;Generate a synthetic trigger signal for an external ECU

	uint16_t autoscale fordInjectorSmallPulseSlope;;"", 0.001, 0, 0, 65, 3

	uint8_t autoscale lambdaProtectionMinRpm;;"RPM", 100, 0, 0, 25000, 0
	uint8_t autoscale lambdaProtectionMinLoad;;"%", 10, 0, 0, 1000, 0

bit is_enabled_spi_1
bit is_enabled_spi_2
	bit is_enabled_spi_3
	bit isSdCardEnabled;enable sd/disable sd
	bit rusefiVerbose29b,"29 bit","11 bit";Use 11 bit (standard) or 29 bit (extended) IDs for FOME verbose CAN format.
	bit unused644b5
	bit useStepperIdle;This setting should only be used if you have a stepper motor idle valve and a stepper motor driver installed.
	
	bit enabledStep1Limiter
	bit verboseTLE8888
	bit enableVerboseCanTx;CAN broadcast using custom FOME protocol\nenable can_broadcast/disable can_broadcast
	bit unused644b10
	bit unused644b11
	bit measureMapOnlyInOneCylinder;Useful for individual intakes
	bit stepperForceParkingEveryRestart
	bit isFasterEngineSpinUpEnabled;If enabled, try to fire the engine before a full engine cycle has been completed using RPM estimated from the last 90 degrees of engine rotation. As soon as the trigger syncs plus 90 degrees rotation, fuel and ignition events will occur. If disabled, worst case may require up to 4 full crank rotations before any events are scheduled.
	bit coastingFuelCutEnabled;This setting disables fuel injection while the engine is in overrun, this is useful as a fuel saving measure and to prevent back firing.
	bit disableFuelCutOnClutch;True: Inhibits DFCO from activating when the clutch is pressed.  This helps prevent transient knock during shifts\n\nFalse: Do not take clutch state into account.
	bit useIacTableForCoasting;Override the IAC position during overrun conditions to help reduce engine breaking, this can be helpful for large engines in light weight cars or engines that have trouble returning to idle.
	bit useIdleTimingPidControl
	bit disableEtbWhenEngineStopped;Allows disabling the ETB when the engine is stopped. You may not like the power draw or PWM noise from the motor, so this lets you turn it off until it's necessary.
	bit is_enabled_spi_4
	bit pauseEtbControl;Disable the electronic throttle motor and DC idle motor for testing.\nThis mode is for testing ETB/DC idle position sensors, etc without actually driving the throttle.
	bit alignEngineSnifferAtTDC
	bit enableAemXSeries;AEM X-Series or rusEFI Wideband
	bit useTableForDfcoMap,"Table","Fixed";Fixed: MAP threshold cut fuel when conditions are met\nTable: Use a curve to vary the MAP threshold based on engine RPM
	bit postCrankingFuelUseTable,"Table","Basic";Basic: Add a fixed percent of added fuel and taper over time\nTable: Use a 3d map to set the added fuel multiplier by CLT and Runtime

	brain_input_pin_e[LOGIC_ANALYZER_CHANNEL_COUNT iterate] logicAnalyzerPins;

	! 536870911 = 2^29-1, the maximum valid extended ID
	uint32_t verboseCanBaseAddress;;"", 1, 0, 0, 536870911, 0

	uint8_t mc33_hvolt;Boost Voltage;"v", 1, 0, 40, 70, 0
	uint8_t minimumBoostClosedLoopMap;Minimum MAP before closed loop boost is enabled. Use to prevent misbehavior upon entering boost.;"kPa", 1, 0, 0, 255, 0

output_pin_e acFanPin;Optional Radiator Fan used with A/C
	pin_output_mode_e acFanPinMode;


	spi_device_e l9779spiDevice;

	uint16_t vehicleWeight;For reference, not used by the ECU.;"kg", 1, 0, 0, 10000, 0
	int16_t idlePidRpmUpperLimit;How far above idle speed do we consider idling?\nFor example, if target = 800, this param = 200, then anything below 1000 RPM is considered idle.;"RPM", 1, 0, 0, 500, 0

	uint16_t autoscale applyNonlinearBelowPulse;Apply nonlinearity correction below a pulse of this duration. Pulses longer than this duration will receive no adjustment.;"ms", {1/1000}, 0, 0, 30, 3
	Gpio lps25BaroSensorScl
	Gpio lps25BaroSensorSda

	brain_input_pin_e vehicleSpeedSensorInputPin;
	switch_input_pin_e clutchUpPin;Some vehicles have a switch to indicate that clutch pedal is all the way up
	custom InjectorNonlinearMode 1 bits, U08, @OFFSET@, [0:1], "None", "Polynomial", "Ford (dual slope)"
	InjectorNonlinearMode injectorNonlinearMode
	pin_input_mode_e clutchUpPinMode;

	Gpio[EGT_CHANNEL_COUNT iterate] max31855_cs;
	brain_input_pin_e flexSensorPin;Continental/GM flex fuel sensor, 50-150hz type;
	uint8_t autoscale tachSweepTime;Total time for the tach to sweep up then back down at startup. Set to 0 to disable sweep.;"s", 0.1, 0, 0, 10, 1
	uint8_t autoscale tachSweepMax;Maximum RPM for the startup tach sweep.;"rpm", 50, 0, 0, 12500, 0
	pin_output_mode_e stepperDirectionPinMode;

	spi_device_e mc33972spiDevice;
	uint8_t autoscale stoichRatioSecondary;Stoichiometric ratio for your secondary fuel. This value is used when the Flex Fuel sensor indicates E100, typically 9.0;":1", {1/@@PACK_MULT_AFR_CFG@@}, 0, 5, 25, 1
	uint8_t etbMaximumPosition;Maximum allowed ETB position. Some throttles go past fully open, so this allows you to limit it to fully open.;"%", 1, 0, 70, 100, 0


custom uart_device_e 1 bits, U08, @OFFSET@, [0:1], "Off", "UART1", "UART2", "UART3"
	uint16_t sdCardLogFrequency;Rate the ECU will log to the SD card, in hz (log lines per second).;"hz", 1, 0, 1, 250, 0
	Gpio debugMapAveraging;
	output_pin_e starterRelayDisablePin;
	pin_output_mode_e starterRelayDisablePinMode;On some vehicles we can disable starter once engine is already running

	custom imu_type_e 1 bits, U08, @OFFSET@, [0:4], "None", "VAG", "MM5.10", "type 3", "type 4"
	imu_type_e imuType

	switch_input_pin_e startStopButtonPin
	
	int mapMinBufferLength;This many MAP samples are used to estimate the current MAP. This many samples are considered, and the minimum taken. Recommended value is 1 for single-throttle engines, and your number of cylinders for individual throttle bodies.;"count", 1, 0, 1, 24, 0
	int16_t idlePidDeactivationTpsThreshold;Below this throttle position, the engine is considered idling. If you have an electronic throttle, this checks accelerator pedal position instead of throttle position, and should be set to 1-2%.;"%", 1, 0, 0, 50, 0
	int16_t stepperParkingExtraSteps;;"%", 1, 0, 0, 3000, 0
	uint16_t tps1SecondaryMin;;"ADC", 1, 0, 0, 1000, 0
	uint16_t tps1SecondaryMax;;"ADC", 1, 0, 0, 1000, 0
	int16_t antiLagRpmTreshold;;"rpm", 1, 0, 0, 20000, 0
	uint16_t startCrankingDuration;Maximum time to crank starter when start/stop button is pressed;"Seconds", 1, 0, 0, 30, 0

	uint8_t lambdaProtectionMinTps;;"%", 1, 0, 0, 100, 0
	uint8_t autoscale lambdaProtectionTimeout;Only respond once lambda is out of range for this period of time. Use to avoid transients triggering lambda protection when not needed;"s", 0.1, 0, 0, 10, 1

	uint8_t autoscale lambdaProtectionRestoreRpm;;"RPM", 100, 0, 0, 25000, 0

	pin_output_mode_e acRelayPinMode;
	output_pin_e acRelayPin;

	uint8_t autoscale minimumOilPressureTimeout;Delay before cutting fuel due to low oil pressure. Use this to ignore short pressure blips and sensor noise.;"sec", 0.1, 0, 0, 5, 1

	spi_device_e drv8860spiDevice;



custom script_setting_t 4 scalar, F32, @OFFSET@, 		"",	   1,	   0, 0, 18000,	  2
	script_setting_t[SCRIPT_SETTING_COUNT iterate] scriptSetting;

	Gpio spi1mosiPin;
	Gpio spi1misoPin;
	Gpio spi1sckPin;
	Gpio spi2mosiPin;

	Gpio spi2misoPin;
	Gpio spi2sckPin;
	Gpio spi3mosiPin;
	Gpio spi3misoPin;

	Gpio spi3sckPin;
	uart_device_e consoleUartDevice;


#define sensor_chart_e_enum "none", "trigger", "INVALID", "RPM ACCEL", "DETAILED RPM", "Fast Aux1"
custom sensor_chart_e 1 bits, S08, @OFFSET@, [0:2], @@sensor_chart_e_enum@@
sensor_chart_e sensorChartMode;FOME console sensor sniffer mode;

#define CAN_RX_PREFIX "CAN_rx"

#define CRITICAL_PREFIX "CRITICAL"
! same length used for critical and soft error messages
#define ERROR_BUFFER_SIZE 120

#define VIN_NUMBER_SIZE 17
	custom vin_number_t @@VIN_NUMBER_SIZE@@ string, ASCII, @OFFSET@, @@VIN_NUMBER_SIZE@@

	custom vehicle_info_t @@VEHICLE_INFO_SIZE@@ string, ASCII, @OFFSET@, @@VEHICLE_INFO_SIZE@@
	custom gppwm_note_t @@GPPWM_NOTE_SIZE@@ string, ASCII, @OFFSET@, @@GPPWM_NOTE_SIZE@@

	bit clutchUpPinInverted
	bit clutchDownPinInverted
	bit useHbridgesToDriveIdleStepper;If enabled we use two H-bridges to drive stepper idle air valve
	bit multisparkEnable
	bit enableLaunchRetard
	bit enableCanVss;Read VSS from OEM CAN bus according to selected CAN vehicle configuration.
	bit enableInnovateLC2
	bit enableOilPressureProtect
	bit stftIgnoreErrorMagnitude;If enabled, adjust at a constant rate instead of a rate proportional to the current lambda error. This mode may be easier to tune, and more tolerant of sensor noise.
	bit enableSoftwareKnock
	bit verboseVVTDecoding;Verbose info in console below engineSnifferRpmThreshold\nenable vvt_details
	bit invertCamVVTSignal;get invertCamVVTSignal
	bit alphaNUseIat;In Alpha-N mode, compensate for air temperature.
	bit knockBankCyl1,"Channel 2","Channel 1"
	bit knockBankCyl2,"Channel 2","Channel 1"
	bit knockBankCyl3,"Channel 2","Channel 1"
	bit knockBankCyl4,"Channel 2","Channel 1"
	bit knockBankCyl5,"Channel 2","Channel 1"
	bit knockBankCyl6,"Channel 2","Channel 1"
	bit knockBankCyl7,"Channel 2","Channel 1"
	bit knockBankCyl8,"Channel 2","Channel 1"
	bit knockBankCyl9,"Channel 2","Channel 1"
	bit knockBankCyl10,"Channel 2","Channel 1"
	bit knockBankCyl11,"Channel 2","Channel 1"
	bit knockBankCyl12,"Channel 2","Channel 1"
	bit tcuEnabled
bit canBroadcastUseChannelTwo,"second","first"
	bit useRawOutputToDriveIdleStepper;If enabled we use four Push-Pull outputs to directly drive stepper idle air valve coilss
bit verboseCan2,"Print all","Do not print";Print incoming and outgoing second bus CAN messages in FOME console


	dc_io[ETB_COUNT iterate] etbIo


    output_pin_e boostControlPin;Wastegate control Solenoid;
	pin_output_mode_e boostControlPinMode;

	custom boostType_e 1 bits, U08, @OFFSET@, [0:0], "Open Loop", "Open + Closed Loop"
	boostType_e boostType;

    switch_input_pin_e ALSActivatePin;
    switch_input_pin_e launchActivatePin;

    pid_s boostPid;
    int boostPwmFrequency;;"Hz", 1, 0, 0, 3000, 0

	#define launchActivationMode_e_enum "Launch Button", "Clutch Down Switch", "Always Active(Disabled By Speed)"
    custom launchActivationMode_e  1 bits, S08, @OFFSET@, [0:1], @@launchActivationMode_e_enum@@
    launchActivationMode_e launchActivationMode;

    #define antiLagActivationMode_e_enum "Switch Input", "Always Active"
    custom antiLagActivationMode_e  1 bits, S08, @OFFSET@, [0:0], @@antiLagActivationMode_e_enum@@
    antiLagActivationMode_e antiLagActivationMode;

	Gpio mc33816_flag0;

    int launchSpeedThreshold;Disabled above this speed;"Kph", 1, 0, 0, 300, 0
    int launchTimingRpmRange;Range from Launch RPM for Timing Retard to activate;"RPM", 1, 0, 0, 8000, 0
    int launchFuelAdded;Extra Fuel Added;"%", 1, 0, 0, 100, 0
    int launchBoostDuty;Duty Cycle for the Boost Solenoid;"%", 1, 0, 0, 100, 0
	int hardCutRpmRange;Range from Launch RPM to activate Hard Cut;"RPM", 1, 0, 0, 3000, 0
	float turbochargerFilter
	int launchTpsThreshold;;"", 1, 0, 0, 20000, 0
	float launchActivateDelay;;"", 1, 0, 0, 20000, 0

	stft_s stft

	dc_io[DC_PER_STEPPER iterate] stepperDcIo

	vehicle_info_t engineMake;For example, BMW, GM or Chevrolet
	vehicle_info_t engineCode;For example, LS1 or NB2
	vehicle_info_t vehicleName;For example, Hunchback or Orange Miata\nVehicle name has to be unique between your vehicles.

	output_pin_e[TCU_SOLENOID_COUNT iterate] tcu_solenoid;

	custom dc_function_e 1 bits, U08, @OFFSET@, [0:1], "None", "Throttle 1", "Throttle 2", "Wastegate"
	dc_function_e[ETB_COUNT iterate] etbFunctions

	Gpio       drv8860_cs;
	pin_output_mode_e drv8860_csPinMode;


! todo: convert this into a bit setting no need for 4 bytes and we do not expect a third option any day soon
custom idle_mode_e 1 bits, U08, @OFFSET@, [0:0], "Open Loop + Closed Loop", "Open Loop"
	idle_mode_e idleMode

	Gpio       drv8860_miso;

	output_pin_e[LUA_PWM_COUNT iterate] luaOutputPins

    int16_t[CAM_INPUTS_COUNT iterate] autoscale vvtOffsets;Angle between cam sensor and VVT zero position;"value", 0.1, 0, -720, 1000, 1

struct vr_threshold_s
	uint8_t[6] autoscale rpmBins;;"rpm", 50, 0, 0, 12000, 0
	uint8_t[6] autoscale values;;"volts", {1/@@PACK_PERCENT_BYTE_MULT@@}, 0, 0, 2.5, 2
	Gpio pin;
end_struct

! todo: should be '3' since we are dreaming of Honda triple-channel distributor
#define VR_THRESHOLD_COUNT 2
	vr_threshold_s[VR_THRESHOLD_COUNT iterate] vrThreshold;

    gppwm_note_t[GPPWM_CHANNELS iterate] gpPwmNote;

	uint16_t tps2SecondaryMin;;"ADC", 1, 0, 0, 1000, 0
	uint16_t tps2SecondaryMax;;"ADC", 1, 0, 0, 1000, 0

	bit widebandOnSecondBus,"2","1";Select which bus the wideband controller is attached to.
	bit fuelClosedLoopCorrectionEnabled;Enables lambda sensor closed loop feedback for fuelling.
	bit unused1192b2
	bit boardUseTachPullUp,"12v","5v"
	bit boardUseTempPullUp,"With Pull Ups","Piggyback Mode"
	bit yesUnderstandLocking,"yes","no"
	bit silentTriggerError;Sometimes we have a performance issue while printing error
	bit useLinearCltSensor
	bit canReadEnabled;enable can_read/disable can_read
	bit canWriteEnabled;enable can_write/disable can_write
	bit useLinearIatSensor
	bit boardUse2stepPullDown,"With Pull Down","With Pull Up"
	bit tachPulseDurationAsDutyCycle,"Duty cycle","Constant time";Treat milliseconds value as duty cycle value, i.e. 0.5ms would become 50%
	bit isAlternatorControlEnabled;This enables smart alternator control and activates the extra alternator settings.
	bit invertPrimaryTriggerSignal;Invert the signal from the primary trigger sensor.
	bit invertSecondaryTriggerSignal;Invert the signal from the secondary trigger sensor.
	
bit cutFuelOnHardLimit,"yes","no";Cut fuel above the hard RPM limit.
bit cutSparkOnHardLimit,"yes","no";Cut spark above the hard RPM limit. WARNING: some engines are known to self-disassemble their valvetrain with a spark cut. Fuel cut is much safer. Use with extreme caution.
bit launchFuelCutEnable
bit launchSparkCutEnable;This is the Cut Mode normally used
	bit boardUseCrankPullUp,"Hall","VR"
	bit boardUseCamPullDown,"With Pull Down","With Pull Up"
	bit boardUseCamVrPullUp,"Hall","VR"
	bit boardUseD2PullDown,"With Pull Down","With Pull Up"
	bit boardUseD3PullDown,"With Pull Down","With Pull Up"
	bit boardUseD4PullDown,"With Pull Down","With Pull Up"
	bit boardUseD5PullDown,"With Pull Down","With Pull Up"
bit verboseIsoTp
bit engineSnifferFocusOnInputs
bit launchActivateInverted
bit twoStroke,"Two Stroke","Four Stroke"
bit skippedWheelOnCam,"On camshaft","On crankshaft";Where is your primary skipped wheel located?

	switch_input_pin_e acSwitch;A/C button input;
	adc_channel_e vRefAdcChannel;
	uint8_t etbNeutralPosition;Expected neutral position;"%", 1, 0, 0, 100, 0

	bit isInjectionEnabled
	bit isIgnitionEnabled
	bit isCylinderCleanupEnabled;When enabled if TPS is held above 95% no fuel is injected while cranking to clear excess fuel from the cylinders.
	bit complexWallModel,"Advanced (tables)","Basic (constants)";Should we use tables to vary tau/beta based on CLT/MAP, or just with fixed values?
	bit alwaysInstantRpm
	bit isMapAveragingEnabled
	bit useCrankingIdleTaperTableSetting; If enabled, use separate temperature multiplier table for cranking taper duration.
	bit overrideCrankingIacSetting;If enabled, use separate temperature multiplier table for cranking idle position.\nIf disabled, use normal running multiplier table applied to the cranking base position.
	bit useSeparateAdvanceForIdle;This activates a separate ignition timing table for idle conditions, this can help idle stability by using ignition retard and advance either side of the desired idle speed. Extra retard at low idle speeds will prevent stalling and extra advance at high idle speeds can help reduce engine power and slow the idle speed.
	bit isWaveAnalyzerEnabled
	bit useSeparateVeForIdle;This activates a separate fuel table for Idle, this allows fine tuning of the idle fuelling.
	bit verboseTriggerSynchDetails;Verbose info in console below engineSnifferRpmThreshold\nenable trigger_details
	bit unused1188b12
	bit canBroadcastEgt;Disable to skip cam data frame (base + 9) if you have no EGT sensing.
	bit canBroadcastCams;Disable to skip cam data frame (base + 8) if you have no VVT.
	bit unused1200b14
bit useFixedBaroCorrFromMap
bit useSeparateAdvanceForCranking,"Table","Fixed (auto taper)";In Constant mode, timing is automatically tapered to running as RPM increases.\nIn Table mode, the "Cranking ignition advance" table is used directly.
bit useAdvanceCorrectionsForCranking;This enables the various ignition corrections during cranking (IAT, CLT, FSIO and PID idle).\nYou probably don't need this.
bit flexCranking;Enable a second cranking table to use for E100 flex fuel, interpolating between the two based on flex fuel sensor.
bit useIacPidMultTable;This flag allows to use a special 'PID Multiplier' table (0.0-1.0) to compensate for nonlinear nature of IAC-RPM controller
bit isBoostControlEnabled
bit launchSmoothRetard;Interpolates the Ignition Retard from 0 to 100% within the RPM Range
bit isPhaseSyncRequiredForIgnition;Some engines are OK running semi-random sequential while other engine require phase synchronization
bit useCltBasedRpmLimit,"yes","no";If enabled, use a curve for RPM limit (based on coolant temperature) instead of a constant value.
bit forceO2Heating,"yes","no";If enabled, don't wait for engine start to heat O2 sensors. WARNING: this will reduce the life of your sensor, as condensation in the exhaust from a cold start can crack the sensing element.
bit invertVvtControlIntake,"retard","advance";If increased VVT duty cycle increases the indicated VVT angle, set this to 'advance'. If it decreases, set this to 'retard'. Most intake cams use 'advance', and most exhaust cams use 'retard'.
bit invertVvtControlExhaust,"retard","advance";If increased VVT duty cycle increases the indicated VVT angle, set this to 'advance'. If it decreases, set this to 'retard'. Most intake cams use 'advance', and most exhaust cams use 'retard'.
bit useBiQuadOnAuxSpeedSensors
bit sdTriggerLog,"trigger","normal";'Trigger' mode will write a high speed log of trigger events (warning: uses lots of space!). 'Normal' mode will write a standard MLG of sensors, engine function, etc. similar to the one captured in TunerStudio.
bit ALSActivateInverted

	uint32_t engineChartSize;;"count", 1, 0, 0, 300, 0



	float turboSpeedSensorMultiplier;;"mult", 1, 0, 0, 7000, 3

	int16_t acIdleRpmBump;Extra idle target speed when A/C is enabled. Some cars need the extra speed to keep the AC efficient while idling.;"RPM", 1, 0, 0, 1000, 0

	int16_t warningPeriod;;"seconds", 1, 0, 0, 60, 0

	float knockDetectionWindowStart;Delay after spark firing to start the knock detection window. This should remain at 0 unless there's a good reason.;"deg", 1, 0, 0, 90, 0
	float knockDetectionWindowEnd;Duration, in crank degrees, of the knock detection window. 40 to 70 degrees is a normal range.;"deg", 1, 0, 30, 100, 0


float idleStepperReactionTime;;"ms", 1, 0, 1, 300, 0


	int idleStepperTotalSteps;;"count", 1, 0, 5, 3000, 0

	#define pin_mode_e_enum "default", "INVALID", "INVALID", "INVALID", "opendrain", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PULLUP", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PULLDOWN"
custom pin_mode_e 1 bits, U08, @OFFSET@, [0:6], @@pin_mode_e_enum@@
	

! todo: rename field remove 'ms', also fix typo in name should be 'tachPulseDuration' and that would be an incompatible breaking change for users :(
	float tachPulseDuractionMs;Duration in ms or duty cycle depending on selected mode;"", 1, 0, 0, 100, 2

	
	float wwaeTau;Length of time the deposited wall fuel takes to dissipate after the start of acceleration. ;"Seconds", 1, 0, 0, 3, 2
	pid_s alternatorControl;
	pid_s etb;
	int16_t airTaperRpmRange;RPM range above upper limit for extra air taper;"RPM", 1, 0, 0, 1500, 0
	brain_input_pin_e turboSpeedSensorInputPin;
int16_t tps2Min;;"ADC", 1, 0, 0, 1023, 0
int16_t tps2Max;;"ADC", 1, 0, 0, 1023, 0
	output_pin_e starterControlPin
	pin_input_mode_e startStopButtonMode;
	uint8_t tachPulsePerRev;;"Pulse", 1, 0, 1, 255, 0

! todo: mapErrorDetectionIdleTooLow? 30kPa is usually lowest on idle	
	float mapErrorDetectionTooLow;kPa value which is too low to be true;"kPa", 1, 0, -100, 100, 2
	float mapErrorDetectionTooHigh;kPa value which is too high to be true;"kPa", 1, 0, -100, 800, 2
	uint16_t autoscale multisparkSparkDuration;How long to wait for the spark to fire before recharging the coil for another spark.;"ms", 0.001, 0, 0, 3, 2
	uint16_t autoscale multisparkDwell;This sets the dwell time for subsequent sparks. The main spark's dwell is set by the dwell table.;"ms", 0.001, 0, 0, 3, 2
	pid_s idleRpmPid
	float wwaeBeta;0 = No fuel settling on port walls 1 = All the fuel settling on port walls setting this to 0 disables the wall wetting enrichment. ;"Fraction", 1, 0, 0, 1, 2

	Gpio[AUX_DIGITAL_VALVE_COUNT iterate] auxValves
	switch_input_pin_e tcuUpshiftButtonPin
	switch_input_pin_e tcuDownshiftButtonPin

	float throttlePedalUpVoltage;;"voltage", 1, 0, -6, 6, 2
	float throttlePedalWOTVoltage;Pedal in the floor;"voltage", 1, 0, -6, 6, 2
	
	int16_t startUpFuelPumpDuration;on IGN voltage detection turn fuel pump on to build fuel pressure;"seconds", 1, 0, 0, 6000, 0
	int16_t idlePidRpmDeadZone;If the RPM closer to target than this value, disable closed loop idle correction to prevent oscillation;"RPM", 1, 0, 0, 800, 0
	

	float targetVBatt;This is the target battery voltage the alternator PID control will attempt to maintain;"Volts", 1, 0, 0, 30, 1
	uint32_t unused1372
	int16_t afterCrankingIACtaperDuration;This is the duration in cycles that the IAC will take to reach its normal idle position, it can be used to hold the idle higher for a few seconds after cranking to improve startup.;"cycles", 1, 0, 0, 5000, 0
	
	int16_t iacByTpsTaper;Extra IAC, in percent between 0 and 100, tapered between zero and idle deactivation TPS value;"percent", 1, 0, 0, 500, 0

	Gpio auxSerialTxPin;Auxiliary sensor serial, not to be confused with secondary calibration serial;
	Gpio auxSerialRxPin;Auxiliary sensor serial, not to be confused with secondary calibration serial;
	Gpio LIS302DLCsPin;


	uint8_t autoscale tpsAccelLookback;How long to look back for TPS-based acceleration enrichment. Increasing this time will trigger enrichment for longer when a throttle position change occurs.;"sec", 0.05, 0, 0, 5, 2
	uint8_t coastingFuelCutVssLow;Below this speed, disable DFCO. Use this to prevent jerkiness from fuel enable/disable in low gears.;"kph", 1, 0, 0, 255, 0
	uint8_t coastingFuelCutVssHigh;Above this speed, allow DFCO. Use this to prevent jerkiness from fuel enable/disable in low gears.;"kph", 1, 0, 0, 255, 0
	uint8_t autoscale noFuelTrimAfterDfcoTime;Pause closed loop fueling after deceleration fuel cut occurs. Set this to a little longer than however long is required for normal fueling behavior to resume after fuel cut.;"sec", 0.1, 0, 0, 10, 1
	uint8_t autoscale ignTestOnTime;Duration of each test pulse;"ms", 0.1, 0, 0, 10, 1
	float tpsAccelEnrichmentThreshold;Maximum change delta of TPS percentage over the 'length'. Actual TPS change has to be above this value in order for TPS/TPS acceleration to kick in.;"roc", 1, 0, 0, 200, 1

    brain_input_pin_e[2 iterate] auxSpeedSensorInputPin;
	uint8_t totalGearsCount;;"", 1, 0, 1, @@GEARS_COUNT@@, 0

	custom InjectionTimingMode 1 bits, U08, @OFFSET@, [0:1], "End of injection", "Start of injection", "Center of injection"
	InjectionTimingMode injectionTimingMode;Sets what part of injection's is controlled by the injection phase table.

	debug_mode_e debugMode;See https://wiki.fome.tech/r/debugmode
	uint8_t fan1ExtraIdle;Additional idle % when fan #1 is active;"%", 1, 0, 0, 100, 0

	uint32_t uartConsoleSerialSpeed;Band rate for primary TTL;"BPs", 1, 0, 0, 1000000, 0
	float tpsDecelEnleanmentThreshold;For decel we simply multiply delta of TPS and tFor decel we do not use table?!;"roc", 1, 0, 0, 200, 1
	float tpsDecelEnleanmentMultiplier;Magic multiplier, we multiply delta of TPS and get fuel squirt duration;"coeff", 1, 0, 0, 200, 2

	uint32_t auxSerialSpeed;;"BPs", 1, 0, 0, 1000000, 0

	float throttlePedalSecondaryUpVoltage;;"voltage", 1, 0, -6, 6, 2
	float throttlePedalSecondaryWOTVoltage;Pedal in the floor;"voltage", 1, 0, -6, 6, 2

	#define can_baudrate_e_enum "50kbps", "83.33kbps", "100kbps", "125kbps", "250kbps", "500kbps", "1Mbps"
	custom can_baudrate_e 1 bits, U08, @OFFSET@, [0:2], @@can_baudrate_e_enum@@
	can_baudrate_e canBaudRate; set can_baudrate

	ve_override_e veOverrideMode;Override the Y axis (load) value used for the VE table.\nAdvanced users only: If you aren't sure you need this, you probably don't need this.

	can_baudrate_e can2BaudRate;

	#define load_override_e_enum "None", "MAP", "TPS", "Acc Pedal", "Cyl Filling %"
	custom load_override_e 1 bits, U08, @OFFSET@, [0:2], @@load_override_e_enum@@
	load_override_e afrOverrideMode;Override the Y axis (load) value used for the AFR table.\nAdvanced users only: If you aren't sure you need this, you probably don't need this.

	uint8_t autoscale mc33_hpfp_i_peak;;"A", 0.1, 0, 0, 25, 1
	uint8_t autoscale mc33_hpfp_i_hold;;"A", 0.1, 0, 0, 25, 1
	uint8_t mc33_hpfp_i_hold_off;How long to deactivate power when hold current is reached before applying power again;"us", 1, 0, 0, 255, 0
	uint8_t mc33_hpfp_max_hold;Maximum amount of time the solenoid can be active before assuming a programming error;"ms", 1, 0, 0, 255, 0

	bit stepperDcInvertedPins;Enable if DC-motor driver (H-bridge) inverts the signals (eg. RZ7899 on Hellen boards)
	bit canOpenBLT; Allow OpenBLT on Primary CAN
	bit can2OpenBLT; Allow OpenBLT on Secondary CAN
	bit injectorFlowAsMassFlow,"mass flow","volumetric flow";Select whether to configure injector flow in volumetric flow (defualt, cc/min) or mass flow (g/s).
	uint8_t autoscale benchTestOffTime;Time between bench test pulses;"ms", 5, 0, 0, 2000, 0

	uint8_t lambdaProtectionRestoreTps;;"%", 1, 0, 0, 100, 0
	uint8_t autoscale lambdaProtectionRestoreLoad;;"%", 10, 0, 0, 1000, 0

	pin_input_mode_e launchActivatePinMode;
	Gpio can2TxPin;set_can2_tx_pin X
	Gpio can2RxPin;set_can2_rx_pin X
	pin_output_mode_e starterControlPinMode;
	adc_channel_e wastegatePositionSensor;
	load_override_e ignOverrideMode;Override the Y axis (load) value used for the ignition table.\nAdvanced users only: If you aren't sure you need this, you probably don't need this.


	custom injector_pressure_type_e 1 bits, U08, @OFFSET@, [0:0], "Low", "High"
	injector_pressure_type_e injectorPressureType;Select which fuel pressure sensor measures the pressure of the fuel at your injectors.

	output_pin_e hpfpValvePin;
	pin_output_mode_e hpfpValvePinMode;

	spi_device_e accelerometerSpiDevice;

	float boostCutPressure;MAP value above which fuel is cut in case of overboost.\nSet to 0 to disable overboost cut.;"kPa (absolute)", 1, 0, 0, 1000, 0

	uint8_t[16] autoscale tchargeBins;;"kg/h", 5, 0, 0, 1200, 0
	uint8_t[16] autoscale tchargeValues;;"ratio", 0.01, 0, 0, 1, 2

	float fixedTiming;Fixed timing, useful for TDC testing;"deg", 1, 0, -720, 720, 2
	float mapLowValueVoltage;MAP voltage for low point;"v", 1, 0, 0, 10, 2
	float mapHighValueVoltage;MAP voltage for low point;"v", 1, 0, 0, 10, 2
	float egoValueShift;EGO value correction;"value", 1, 0, -10, 10, 2

	output_pin_e[CAM_INPUTS_COUNT iterate] vvtPins;VVT output solenoid pin for this cam

	int crankingIACposition;This is the IAC position during cranking, some engines start better if given more air during cranking to improve cylinder filling.;"percent", 1, 0, -100, 100, 0
	float tChargeMinRpmMinTps;;"", 1, 0, 0, 3, 4
	float tChargeMinRpmMaxTps;;"", 1, 0, 0, 3, 4
	float tChargeMaxRpmMinTps;;"", 1, 0, 0, 3, 4
	float tChargeMaxRpmMaxTps;;"", 1, 0, 0, 3, 4

custom pwm_freq_t 2 scalar, U16, @OFFSET@, "Hz", 1, 0, 0, 3000, 0
	pwm_freq_t vvtOutputFrequency
	int8_t minimumIgnitionTiming;Minimim timing advance allowed. No spark on any cylinder will ever fire after this angle BTDC. For example, setting -10 here means no spark ever fires later than 10 deg ATDC. Note that this only concerns the primary spark: any trailing sparks or multispark may violate this constraint.;"deg BTDC", 1, 0, -90, 90, 0
	int8_t maximumIgnitionTiming;Maximum timing advance allowed. No spark on any cylinder will ever fire before this angle BTDC. For example, setting 45 here means no spark ever fires earlier than 45 deg BTDC;"deg BTDC", 1, 0, -90, 90, 0
	int alternatorPwmFrequency;;"Hz", 1, 0, 0, 3000, 0


	vvt_mode_e[CAMS_PER_BANK iterate] vvtMode
	uint8_t fan2ExtraIdle;Additional idle % when fan #2 is active;"%", 1, 0, 0, 100, 0
	uint8_t autoscale primingDelay;Delay to allow fuel pressure to build before firing the priming pulse.;"sec", 0.01, 0, 0, 1, 2
! todo: rename to luaAnalogInputs
	adc_channel_e[LUA_ANALOG_INPUT_COUNT iterate] auxAnalogInputs;

	output_pin_e[MAX_CYLINDER_COUNT iterate] trailingCoilPins;
custom tle8888_mode_e 1 bits, U08, @OFFSET@, [0:1], "Auto", "SemiAuto", "Manual", "Hall"
tle8888_mode_e tle8888mode;

	pin_output_mode_e LIS302DLCsPinMode;

	custom injector_compensation_mode_e 1 bits, U08, @OFFSET@, [0:1], "None", "Fixed rail pressure", "Sensed Rail Pressure"
	injector_compensation_mode_e injectorCompensationMode;None = I have a MAP-referenced fuel pressure regulator\nFixed rail pressure = I have an atmosphere-referenced fuel pressure regulator (returnless, typically)\nSensed rail pressure = I have a fuel pressure sensor;

	pin_output_mode_e fan2PinMode;
	float fuelReferencePressure;This is the pressure at which your injector flow is known.\nFor example if your injectors flow 400cc/min at 3.5 bar, enter 350kpa here.;"kPa", 1, 0, 50, 700000, 0
	float postCrankingFactor;Fuel multiplier (enrichment) immediately after engine start;"mult", 1, 0, 1, 3, 2
	float postCrankingDurationSec;Time over which to taper out after start enrichment;"seconds", 1, 0, 0, 30, 0
	ThermistorConf auxTempSensor1
	ThermistorConf auxTempSensor2
	int16_t knockSamplingDuration;;"Deg", 1, 0, 0, 720, 0
	int16_t etbFreq;;"Hz", 1, 0, 0, @@ETB_HW_MAX_FREQUENCY@@, 0
	pid_s etbWastegatePid;

#define stepper_num_micro_steps_e_enum "Full-Step (Default)", "INVALID", "Half-Step", "INVALID", "1/4 Micro-Step", "INVALID", "INVALID", "INVALID", "1/8 Micro-Step"
custom stepper_num_micro_steps_e 1 bits, U08,	@OFFSET@,	[0:3], @@stepper_num_micro_steps_e_enum@@
	stepper_num_micro_steps_e stepperNumMicroSteps;For micro-stepping, make sure that PWM frequency (etbFreq) is high enough;
	uint8_t stepperMinDutyCycle;Use to limit the current when the stepper motor is idle, not moving (100% = no limit);"%", 1, 0, 0, 100, 0
	uint8_t stepperMaxDutyCycle;Use to limit the max.current through the stepper motor (100% = no limit);"%", 1, 0, 0, 100, 0
	spi_device_e sdCardSpiDevice;

	angle_t[MAX_CYLINDER_COUNT iterate] timing_offset_cylinder;per-cylinder timing correction;"deg", 1, 0, -720, 720, 1

	
	float idlePidActivationTime;;"seconds", 1, 0, 0, 60, 1

	uint8_t[9] unused1800

	pin_output_mode_e stepperEnablePinMode;
	Gpio mc33816_rstb;ResetB
	Gpio mc33816_driven

	switch_input_pin_e brakePedalPin;Brake pedal switch
	pin_input_mode_e brakePedalPinMode;

#define tChargeMode_e_enum "RPM+TPS (Default)", "Air Mass Interpolation", "Table"
custom tChargeMode_e 1 bits, U08, @OFFSET@, [0:1], @@tChargeMode_e_enum@@
tChargeMode_e tChargeMode;

	pin_input_mode_e tcuUpshiftButtonPinMode
	pin_input_mode_e tcuDownshiftButtonPinMode

	pid_s[CAMS_PER_BANK iterate] auxPid;VVT output PID\nTODO: rename to vvtPid
	float[8 iterate] injectorCorrectionPolynomial;;"", 1, 0, -1000, 1000, 4
	int8_t[8] primeBins;;"C", 1, 0, -40, 120, 0

	linear_sensor_s oilPressure;

	output_pin_e fan2Pin;
	uint8_t fan2OnTemperature;Cooling fan turn-on temperature threshold, in Celsius;"deg C", 1, 0, 0, 150, 0
	uint8_t fan2OffTemperature;Cooling fan turn-off temperature threshold, in Celsius;"deg C", 1, 0, 0, 150, 0

#define SCRIPT_CURVE_COUNT 6
#define SCRIPT_TABLE_COUNT 4

	Gpio stepperEnablePin;
	Gpio tle8888_cs;
	pin_output_mode_e tle8888_csPinMode;

	custom can_vss_nbc_e 2 bits, U08, @OFFSET@, [0:1], "BMW_e46", "W202", "BMW E8x/E9x MK60e5"
	can_vss_nbc_e canVssNbcType

	Gpio mc33816_cs;

	float auxFrequencyFilter;;"hz", 1, 0, 0, 100, 1
	int16_t vvtControlMinRpm;;"RPM", 1, 0, 0, 3000, 0

	brain_input_pin_e[SENT_INPUT_COUNT iterate] sentInputPins;

	int8_t launchFuelAdderPercent;;"%", 1, 0, 0, 100, 0
	uint8_t autoscale etbJamTimeout;Time after which the throttle is considered jammed.;"sec", 0.02, 0, 0, 5, 2

	int16_t coastingFuelCutRpmHigh;This sets the RPM above which fuel cut is active.;"rpm", 1, 0, 0, 5000, 0
	int16_t coastingFuelCutRpmLow;This sets the RPM below which fuel cut is deactivated, this prevents jerking or issues transitioning to idle;"rpm", 1, 0, 0, 5000, 0
	int16_t coastingFuelCutTps;Throttle position below which fuel cut is active. With an electronic throttle enabled, this checks against pedal position.;"%", 1, 0, 0, 20, 0
	int16_t coastingFuelCutClt;Fuel cutoff is disabled when the engine is cold.;"C", 1, 0, -100, 100, 0
	
	int16_t pidExtraForLowRpm;Increases PID reaction for RPM<target by adding extra percent to PID-error;"%", 1, 0, 0, 100, 0
	int16_t coastingFuelCutMap;MAP value above which fuel injection is re-enabled.;"kPa", 1, 0, 0, 250, 0

	linear_sensor_s highPressureFuel;
	linear_sensor_s lowPressureFuel;

gppwm_note_t[SCRIPT_CURVE_COUNT iterate] scriptCurveName;

gppwm_note_t[SCRIPT_TABLE_COUNT iterate] scriptTableName;
gppwm_note_t[SCRIPT_SETTING_COUNT iterate] scriptSettingName;

float tChargeAirCoefMin;Heat transfer coefficient at zero flow.\n0 means the air charge is fully heated to the same temperature as CLT.\n1 means the air charge gains no heat, and enters the cylinder at the temperature measured by IAT.;"", 1, 0, 0, 1, 3
float tChargeAirCoefMax;Heat transfer coefficient at high flow, as defined by "max air flow".\n0 means the air charge is fully heated to the same temperature as CLT.\n1 means the air charge gains no heat, and enters the cylinder at the temperature measured by IAT.;"", 1, 0, 0, 1, 3
float tChargeAirFlowMax;High flow point for heat transfer estimation.\nSet this to perhaps 50-75% of your maximum airflow at wide open throttle.;"kg/h", 1, 0, 0, 1000, 1
float tChargeAirIncrLimit;Maximum allowed rate of increase allowed for the estimated charge temperature;"deg/sec", 1, 0, 0, 100, 1
float tChargeAirDecrLimit;Maximum allowed rate of decrease allowed for the estimated charge temperature;"deg/sec", 1, 0, 0, 100, 1

	int16_t etb_iTermMin;iTerm min value;"", 1, 0, -30000, 30000, 0
	int16_t etb_iTermMax;iTerm max value;"", 1, 0, -30000, 30000, 0

	pid_s idleTimingPid

	int16_t tpsAccelFractionPeriod;A delay in cycles between fuel-enrich. portions;"cycles", 1, 0, 0, 500, 0
	float tpsAccelFractionDivisor;A fraction divisor: 1 or less = entire portion at once, or split into diminishing fractions;"coef", 1, 0, 0, 100, 2

	spi_device_e tle8888spiDevice;
	spi_device_e mc33816spiDevice;
	int16_t idlerpmpid_iTermMin;iTerm min value;"", 1, 0, -30000, 30000, 0

	spi_device_e tle6240spiDevice;
	uint8_t autoscale stoichRatioPrimary;Stoichiometric ratio for your primary fuel. When Flex Fuel is enabled, this value is used when the Flex Fuel sensor indicates E0.\nE0 = 14.7\nE10 = 14.1\nE85 = 9.9\nE100 = 9.0;":1", {1/@@PACK_MULT_AFR_CFG@@}, 0, 5, 25, 1
	int16_t idlerpmpid_iTermMax;iTerm max value;"", 1, 0, -30000, 30000, 0



	float etbIdleThrottleRange;This sets the range of the idle control on the ETB. At 100% idle position, the value specified here sets the base ETB position.;"%", 1, 0, 0, 15, 0

	uint8_t[MAX_CYLINDER_COUNT iterate] cylinderBankSelect;Select which fuel correction bank this cylinder belongs to. Group cylinders that share the same O2 sensor;"", 1, 1, 1, 2, 0

	uint8_t[8] autoscale primeValues;;"mg", 5, 0, 0, 1250, 0

	uint8_t autoscale triggerCompCenterVolt;Trigger comparator center point voltage;"V", @@VOLTAGE_1_BYTE_PACKING_DIV@@, 0, 0, 5.1, 2
	uint8_t autoscale triggerCompHystMin;Trigger comparator hysteresis voltage (Min);"V", @@VOLTAGE_1_BYTE_PACKING_DIV@@, 0, 0, 5.1, 2
	uint8_t autoscale triggerCompHystMax;Trigger comparator hysteresis voltage (Max);"V", @@VOLTAGE_1_BYTE_PACKING_DIV@@, 0, 0, 5.1, 2
	uint8_t autoscale triggerCompSensorSatRpm;VR-sensor saturation RPM;"RPM", 50, 0, 0, 12000, 0

	gppwm_channel[GPPWM_CHANNELS iterate] gppwm;

	uint16_t mc33_i_boost;Boost Current;"mA", 1, 0, 1000, 25000, 0
	uint16_t mc33_i_peak;Peak Current;"mA", 1, 0, 1000, 20000, 0
	uint16_t mc33_i_hold;Hold Current;"mA", 1, 0, 1000, 20000, 0
	uint16_t mc33_t_max_boost;Maximum allowed boost phase time. If the injector current doesn't reach the threshold before this time elapses, it is assumed that the injector is missing or has failed open circuit.;"us", 1, 0, 0, 10000, 0
	uint16_t mc33_t_peak_off;;"us", 1, 0, 0, 10000, 0
	uint16_t mc33_t_peak_tot;Peak phase duration;"us", 1, 0, 0, 10000, 0
	uint16_t mc33_t_bypass;;"us", 1, 0, 0, 10000, 0
	uint16_t mc33_t_hold_off;;"us", 1, 0, 0, 10000, 0
	uint16_t mc33_t_hold_tot;Hold phase duration;"us", 1, 0, 0, 10000, 0

	pin_output_mode_e[TCU_SOLENOID_COUNT iterate] tcu_solenoid_mode;

	uint16_t[GAP_TRACKING_LENGTH iterate] autoscale triggerGapOverrideFrom;;"ratio", 0.001, 0, 0, 20, 3
	uint16_t[GAP_TRACKING_LENGTH iterate] autoscale triggerGapOverrideTo;;"ratio", 0.001, 0, 0, 20, 3

	uint8_t autoscale maxCamPhaseResolveRpm;Below this RPM, use camshaft information to synchronize the crank's position for full sequential operation. Use this if your cam sensor does weird things at high RPM. Set to 0 to disable, and always use cam to help sync crank.;"rpm", 50, 0, 0, 12500, 0

	uint8_t autoscale dfcoDelay;Delay before cutting fuel. Set to 0 to cut immediately with no delay. May cause rumbles and pops out of your exhaust...;"sec", 0.1, 0, 0, 10, 1
	uint8_t autoscale acDelay;Delay before engaging the AC compressor. Set to 0 to engage immediately with no delay. Use this to prevent bogging at idle when AC engages.;"sec", 0.1, 0, 0, 10, 1

	pin_input_mode_e acSwitchMode

	uint16_t autoscale fordInjectorSmallPulseBreakPoint;;"mg", 0.001, 0, 0, 65, 3

	uint8_t etbJamDetectThreshold;Threshold in ETB error (target vs. actual) above which the jam timer is started. If the timer reaches the time specified in the jam detection timeout period, the throttle is considered jammed, and engine operation limited.;"%", 1, 0, 0, 50, 0

! Someday there will be a 6th option for BMW S55 that uses a separate shaft just for HPFP
#define hpfp_cam_e_enum "NONE", "Intake 1", "Exhaust 1", "Intake 2", "Exhaust 2"
#define HPFP_LOBE_PROFILE_SIZE 16
#define HPFP_DEADTIME_SIZE 8
#define HPFP_TARGET_SIZE 10
#define HPFP_COMPENSATION_SIZE 10

        custom hpfp_cam_e 1 bits, U08, @OFFSET@, [0:2], @@hpfp_cam_e_enum@@

        uint8_t hpfpCamLobes;;"lobes/cam", 1, 0, 0, 255, 0
        hpfp_cam_e hpfpCam;
        uint8_t hpfpPeakPos;Crank angle ATDC of first lobe peak;"deg", 1, 0, 0, 255, 0
        uint8_t hpfpMinAngle;If the requested activation time is below this angle, don't bother running the pump;"deg", 1, 0, 0, 255, 0

		vin_number_t vinNumber


	uint16_t autoscale hpfpPumpVolume;Size of the pump chamber in cc. Typical Bosch HDP5 has a 9.0mm diameter, typical BMW N* stroke is 4.4mm.;"cc", 0.001, 0, 0, 65, 3
	uint8_t hpfpActivationAngle;How long to keep the valve activated (in order to allow the pump to build pressure and keep the valve open on its own);"deg", 1, 0, 0, 255, 0
	uint8_t issFilterReciprocal;;"", 1, 0, 0, 255, 0
	uint16_t autoscale hpfpPidP;;"%/kPa", 0.001, 0, 0, 65, 3
	uint16_t autoscale hpfpPidI;;"%/kPa/lobe", 0.00001, 0, 0, 0.65, 5
	uint16_t hpfpTargetDecay;The fastest rate the target pressure can be reduced by. This is because HPFP have no way to bleed off pressure other than injecting fuel.;"kPa/s", 1, 0, 0, 65000, 0


	output_pin_e[4 iterate] stepper_raw_output;

    uint16_t[GEARS_COUNT iterate] autoscale gearRatio;;"ratio", 0.01, 0, 0, 10, 2

uint16_t vvtActivationDelayMs;We need to give engine time to build oil pressure without diverting it to VVT;"ms", 1, 0, 0, 65000, 0

#define gear_controller_e_enum "None", "Button Shift"
		custom GearControllerMode 1 bits, U08, @OFFSET@, [0:1], @@gear_controller_e_enum@@
		GearControllerMode gearControllerMode

#define transmission_controller_e_enum "None", "Simple Transmission", "GM 4L6X"
		custom TransmissionControllerMode 1 bits, U08, @OFFSET@, [0:1], @@transmission_controller_e_enum@@
		TransmissionControllerMode transmissionControllerMode

	uint16_t acrDisablePhase;;"deg", 1, 0, 0, 720, 0

linear_sensor_s auxLinear1
linear_sensor_s auxLinear2
linear_sensor_s auxLinear3
linear_sensor_s auxLinear4

output_pin_e tcu_tcc_onoff_solenoid
pin_output_mode_e tcu_tcc_onoff_solenoid_mode
pin_output_mode_e tcu_tcc_pwm_solenoid_mode
output_pin_e tcu_tcc_pwm_solenoid
pwm_freq_t tcu_tcc_pwm_solenoid_freq
output_pin_e tcu_pc_solenoid_pin
pin_output_mode_e tcu_pc_solenoid_pin_mode
pin_output_mode_e tcu_32_solenoid_pin_mode
pwm_freq_t tcu_pc_solenoid_freq
output_pin_e tcu_32_solenoid_pin
pwm_freq_t tcu_32_solenoid_freq

output_pin_e acrPin2;

uint8_t autoscale etbMinimumPosition;Set a minimum allowed target position to avoid slamming/driving against the hard mechanical stop in the throttle.;"%", 0.1, 0, 0, 10, 1

uint16_t tuneHidingKey;;"", 1, 0, 0, 20000, 0

SentEtbType sentEtbType

#define fuel_pressure_sensor_mode_e_enum "Absolute", "Gauge", "Differential", "INVALID"
custom fuel_pressure_sensor_mode_e 1 bits, U08, @OFFSET@, [0:1], @@fuel_pressure_sensor_mode_e_enum@@
fuel_pressure_sensor_mode_e fuelPressureSensorMode

switch_input_pin_e[LUA_DIGITAL_INPUT_COUNT iterate] luaDigitalInputPins;
	int16_t ALSMinRPM;;"rpm", 1, 0, 0, 20000, 0
	int16_t ALSMaxRPM;;"rpm", 1, 0, 0, 20000, 0
int16_t ALSMaxDuration;;"sec", 1, 0, 0, 10, 0
	int8_t ALSMinCLT;;"C", 1, 0, 0, 90, 0
	int8_t ALSMaxCLT;;"C", 1, 0, 0, 105, 0
uint8_t alsMinTimeBetween;;"", 1, 0, 0, 20000, 0
uint8_t alsEtbPosition;;"", 1, 0, 0, 20000, 0
	uint8_t acRelayAlternatorDutyAdder;Add alternator duty while AC is turned on to compensate for the radiator/blower fans.;"%", 1, 0, 0, 100, 0
	uint8_t instantRpmRange;;"deg", 1, 0, 0, 250, 0
	int ALSIdleAdd;;"%", 1, 0, 0, 100, 2
	int ALSEtbAdd;;"%", 1, 0, 0, 100, 2
	int ALSSkipRatio;;"", 1, 0, 0.1, 2, 1
	uint8_t ALSMaxDriverThrottleIntent;;"%", 1, 0, 0, 10, 0
	pin_input_mode_e ALSActivatePinMode;

	uint8_t autoscale tpsSecondaryMaximum;For Ford TPS, use 53%. For Toyota ETCS-i, use ~65%. 0 and 100 disable, <20 invalid, rest will avoid sensor averaging.;"%", 0.5, 0, 0, 100, 1
	uint8_t autoscale ppsSecondaryMaximum;For Toyota ETCS-i, use ~69%. 0 and 100 disable, <20 invalid, rest will avoid sensor averaging.;"%", 0.5, 0, 0, 100, 1
pin_input_mode_e[LUA_DIGITAL_INPUT_COUNT iterate] luaDigitalInputPinModes;

	uint8_t autoscale rpmHardLimitHyst;If the hard limit is 7200rpm and hysteresis is 200rpm, then when the ECU sees 7200rpm, fuel/ign will cut, and stay cut until 7000rpm (7200-200) is reached;"RPM", 10, 0, 0, 2500, 0

	uint8_t ignTestCount;How many test bench pulses do you want;"", 1, 0, 0, 50, 0
	uint8_t autoscale ignTestOffTime;Time between bench test pulses;"ms", 5, 0, 0, 2000, 0

	uint16_t autoscale canVssScaling;Scale the reported vehicle speed value from CAN. Example: Parameter set to 1.1, CAN VSS reports 50kph, ECU will report 55kph instead.;"ratio", 0.0001, 0, 0.5, 1.5, 4

	ThermistorConf oilTempSensor
	ThermistorConf fuelTempSensor
	ThermistorConf ambientTempSensor
	ThermistorConf compressorDischargeTemperature

	adc_channel_e throttleInletPressureChannel;Place the sensor before the throttle, but after any turbocharger/supercharger and intercoolers if fitted. Uses the same calibration as the MAP sensor.
	adc_channel_e compressorDischargePressureChannel;Place the sensor after the turbocharger/supercharger, but before any intercoolers if fitted. Uses the same calibration as the MAP sensor.

	uint8_t maxInjectorDutyInstant;If injector duty cycle hits this value, instantly cut fuel.;"%", 1, 0, 50, 200, 0
	uint8_t maxInjectorDutySustained;If injector duty cycle hits this value for the specified delay time, cut fuel.;"%", 1, 0, 50, 120, 0
	uint8_t autoscale maxInjectorDutySustainedTimeout;Timeout period for duty cycle over the sustained limit to trigger duty cycle protection.;"sec", 0.1, 0, 0, 5, 1

	output_pin_e speedometerOutputPin
	uint16_t speedometerPulsePerKm;Number of speedometer pulses per kilometer travelled.;"", 1, 0, 0, 65000, 0

	Gpio spi4mosiPin;
	Gpio spi4misoPin;
	Gpio spi4sckPin;

	Gpio spi5mosiPin;
	Gpio spi5misoPin;
	Gpio spi5sckPin;

	Gpio spi6mosiPin;
	Gpio spi6misoPin;
	Gpio spi6sckPin;

! end of engine_configuration_s
end_struct

! note that this magic field name is used by LiveDataParserPanel
engine_configuration_s engineConfiguration;

		uint8_t[ETB_BIAS_CURVE_LENGTH] autoscale etbBiasBins;target TPS value, 0 to 100%;"target TPS position", 0.5, 0, 0, 100, 1
		int16_t[ETB_BIAS_CURVE_LENGTH] autoscale etbBiasValues;PWM bias, -100% to 100%. The output of this table is added to the output of the ETB PID function to generate the final ETB Duty output.;"ETB duty cycle bias", 0.1, 0, -100, 100, 1

	uint8_t[IAC_PID_MULT_SIZE x IAC_PID_MULT_SIZE] autoscale iacPidMultTable;;"%", 0.05, 0, 0, 10, 2
	uint8_t[IAC_PID_MULT_SIZE] iacPidMultLoadBins;;"Load", 1, 0, 0, 500, 2
	uint8_t[IAC_PID_MULT_SIZE] autoscale iacPidMultRpmBins;;"RPM", 10, 0, 0, 2500, 0

	uint16_t[DWELL_CURVE_SIZE] sparkDwellRpmBins;On Single Coil or Wasted Spark setups you have to lower dwell at high RPM;"RPM", 1, 0, 0, 25000, 0
	uint16_t[DWELL_CURVE_SIZE] autoscale sparkDwellValues;;"ms", 0.01, 0, 0, 30, 2

	int8_t[CLT_CURVE_SIZE] autoscale cltIdleRpmBins;CLT-based target RPM for automatic idle controller;"C", 2, 0, -40, 200, 0
	uint8_t[CLT_CURVE_SIZE] autoscale cltIdleRpm;Sets the target engine speed that is used for the closed-loop idle air and closed-loop idle timing algorithms.;"RPM", 20, 0, 0, 5000, 0
	float[CLT_TIMING_CURVE_SIZE] cltTimingBins;CLT-based timing correction;"C", 1, 0, -100, 250, 1
	float[CLT_TIMING_CURVE_SIZE] cltTimingExtra;;"degree", 1, 0, -400, 400, 0


	int16_t[SCRIPT_CURVE_16] autoscale scriptCurve1Bins;;"x", 0.1, 0, -3270, 3270, 2
	int16_t[SCRIPT_CURVE_16] autoscale scriptCurve1;;"y", 0.1, 0, -3270, 3270, 2
	int16_t[SCRIPT_CURVE_16] autoscale scriptCurve2Bins;;"x", 0.1, 0, -3270, 3270, 2
	int16_t[SCRIPT_CURVE_16] autoscale scriptCurve2;;"y", 0.1, 0, -3270, 3270, 2
	int16_t[SCRIPT_CURVE_8] autoscale scriptCurve3Bins;;"x", 0.1, 0, -3270, 3270, 2
	int16_t[SCRIPT_CURVE_8] autoscale scriptCurve3;;"y", 0.1, 0, -3270, 3270, 2
	int16_t[SCRIPT_CURVE_8] autoscale scriptCurve4Bins;;"x", 0.1, 0, -3270, 3270, 2
	int16_t[SCRIPT_CURVE_8] autoscale scriptCurve4;;"y", 0.1, 0, -3270, 3270, 2
	int16_t[SCRIPT_CURVE_8] autoscale scriptCurve5Bins;;"x", 0.1, 0, -3270, 3270, 2
	int16_t[SCRIPT_CURVE_8] autoscale scriptCurve5;;"y", 0.1, 0, -3270, 3270, 2
	int16_t[SCRIPT_CURVE_8] autoscale scriptCurve6Bins;;"x", 0.1, 0, -3270, 3270, 2
	int16_t[SCRIPT_CURVE_8] autoscale scriptCurve6;;"y", 0.1, 0, -3270, 3270, 2

	uint16_t[BARO_CORR_SIZE] autoscale baroCorrPressureBins;;"kPa", 0.1, 0, 0, 200, 1
	uint16_t[BARO_CORR_SIZE] baroCorrRpmBins;;"RPM", 1, 0, 0, 65000, 0

	uint16_t[BARO_CORR_SIZE x BARO_CORR_SIZE] autoscale baroCorrTable;;"ratio", 0.001, 0, 0, 2, 3

	float[CRANKING_CURVE_SIZE] crankingTpsCoef;Cranking fuel correction coefficient based on TPS;"Ratio", 1, 0, 0, 700, 2
	float[CRANKING_CURVE_SIZE] crankingTpsBins;;"%", 1, 0, 0, 100, 2

uint16_t[CRANKING_ADVANCE_CURVE_SIZE] crankingAdvanceBins;Optional timing advance table for Cranking (see useSeparateAdvanceForCranking);"RPM", 1, 0, 0, 25000, 0
int16_t[CRANKING_ADVANCE_CURVE_SIZE] autoscale crankingAdvance;Optional timing advance table for Cranking (see useSeparateAdvanceForCranking);"deg", 0.01, 0, -20, 90, 2
uint8_t[CLT_CURVE_SIZE] autoscale iacCoastingRpmBins;RPM-based idle position for coasting;"RPM", 100, 0, 0, 25000, 0
uint8_t[CLT_CURVE_SIZE] autoscale iacCoasting;    RPM-based idle position for coasting;"%", 0.5, 0, 0, 100, 1

uint8_t[BOOST_RPM_COUNT x BOOST_LOAD_COUNT] autoscale boostTableOpenLoop;;"", {1/2}, 0, 0, 100, 1
uint8_t[BOOST_RPM_COUNT] autoscale boostRpmBins;;"RPM", 100, 0, 0, 25000, 0

uint8_t[BOOST_RPM_COUNT x BOOST_LOAD_COUNT] autoscale boostTableClosedLoop;;"", 2, 0, 0, 3000, 0
uint8_t[BOOST_LOAD_COUNT] boostTpsBins;;"%", 1, 0, 0, 100, 0

uint8_t[PEDAL_TO_TPS_SIZE x PEDAL_TO_TPS_SIZE] pedalToTpsTable;;"%", 1, 0, 0, 100, 0
uint8_t[PEDAL_TO_TPS_SIZE] pedalToTpsPedalBins;;"%", 1, 0, 0, 120, 0
uint8_t[PEDAL_TO_TPS_SIZE] autoscale pedalToTpsRpmBins;;"RPM", 100, 0, 0, 25000, 0

float[CLT_CRANKING_CURVE_SIZE] cltCrankingCorrBins;CLT-based cranking position multiplier for simple manual idle controller;"C", 1, 0, -100, 250, 2
float[CLT_CRANKING_CURVE_SIZE] cltCrankingCorr    ;CLT-based cranking position multiplier for simple manual idle controller;"%", 1, 0, 0, 500, 2

int8_t[CLT_CRANKING_CURVE_SIZE] cltCrankingTaperCorrBins;CLT-based taper duration multiplier for simple manual idle controller;"C", 1, 0, -100, 120, 2
uint8_t[CLT_CRANKING_CURVE_SIZE] autoscale cltCrankingTaperCorr    ;CLT-based taper duration multiplier for simple manual idle controller;"%", 0.02, 0, 0, 5, 2

uint8_t[IDLE_ADVANCE_CURVE_SIZE] autoscale idleAdvanceBins;Optional timing advance table for Idle (see useSeparateAdvanceForIdle);"RPM", 50, 0, 0, 12000, 0
float[IDLE_ADVANCE_CURVE_SIZE] idleAdvance    ;Optional timing advance table for Idle (see useSeparateAdvanceForIdle);"deg", 1, 0, -20, 90, 1
uint8_t[IDLE_VE_SIZE] autoscale idleVeRpmBins;;"RPM", 10, 0, 0, 2500, 0
uint8_t[IDLE_VE_SIZE] idleVeLoadBins;;"load", 1, 0, 0, 100, 0
uint16_t[IDLE_VE_SIZE x IDLE_VE_SIZE] autoscale idleVeTable;;"%", 0.1, 0, 0, 999, 1

#define LUA_SCRIPT_SIZE 8000
custom lua_script_t @@LUA_SCRIPT_SIZE@@ string, ASCII, @OFFSET@, @@LUA_SCRIPT_SIZE@@
lua_script_t luaScript;

float[CLT_CURVE_SIZE] cltFuelCorrBins;;"C", 1, 0, -100, 250, 2
float[CLT_CURVE_SIZE] cltFuelCorr;;"ratio", 1, 0, 0, 5, 2

float[IAT_CURVE_SIZE] iatFuelCorrBins;;"C", 1, 0, -100, 250, 2
float[IAT_CURVE_SIZE] iatFuelCorr;;"ratio", 1, 0, 0, 5, 2

	float[CRANKING_CURVE_SIZE] crankingFuelCoef;;"ratio", 1, 0, 0, 50, 2
	float[CRANKING_CURVE_SIZE] crankingFuelBins;;"C", 1, 0, -80, 170, 2

	float[CRANKING_CURVE_SIZE] crankingCycleCoef;;"ratio", 1, 0, 0, 5, 2
	float[CRANKING_CURVE_SIZE] crankingCycleBins;;"counter", 1, 0, -80, 170, 0

float[CLT_CURVE_SIZE] cltIdleCorrBins;CLT-based idle position multiplier for simple manual idle controller;"C", 1, 0, -100, 250, 2
float[CLT_CURVE_SIZE] cltIdleCorr;    CLT-based idle position multiplier for simple manual idle controller;"ratio", 1, 0, 0, 10, 2

uint32_t[MAF_DECODING_COUNT] autoscale mafDecoding;;"kg/hour", 0.001, 0, 0, 4000, 3
uint16_t[MAF_DECODING_COUNT] autoscale mafDecodingBins;;"V", 0.01, 0, 0, 20, 2

int8_t[8 x 8] autoscale ignitionIatCorrTable;;"deg", 0.1, 0, -25, 25, 1
int8_t[8] ignitionIatCorrTempBins;;"C", 1, 0, -40, 120, 0
uint8_t[8] autoscale ignitionIatCorrLoadBins;;"Load", 5, 0, 0, 1000, 0

int16_t[IGN_RPM_COUNT x IGN_LOAD_COUNT] injectionPhase;;"deg", 1, 0, -720, 720, 0
uint16_t[FUEL_LOAD_COUNT] injPhaseLoadBins;;"Load", 1, 0, 0, 1000, 0
uint16_t[FUEL_RPM_COUNT] injPhaseRpmBins;;"RPM",	   1, 0, 0, 18000, 0

uint8_t[TCU_SOLENOID_COUNT x TCU_GEAR_COUNT] tcuSolenoidTable;;"onoff", 1, 0, 0, 1, 0

uint16_t[FUEL_RPM_COUNT x FUEL_LOAD_COUNT] autoscale mapEstimateTable;This table is used as a fallback in case of MAP sensor failure to estimate the MAP value at a given throttle position and engine speed. For example a naturally-aspirated engine's MAP value at 100% TPS should be 100kPa. At 0% TPS and at idle speed this value should be set to the engine's typical idling MAP reading. This table can be populated based on analysis of a log file at different engine speeds and loads.;"kPa", 0.01, 0, 0, 600, 2
uint16_t[FUEL_LOAD_COUNT] autoscale mapEstimateTpsBins;;"% TPS", {1/@@TPS_2_BYTE_PACKING_MULT@@}, 0, 0, 100, 1
uint16_t[FUEL_RPM_COUNT] mapEstimateRpmBins;;"RPM", 1, 0, 0, 18000, 0

int8_t[SCRIPT_TABLE_8 x SCRIPT_TABLE_8] vvtTable1;;"value", 1, 0, -125, 125, 0
uint16_t[SCRIPT_TABLE_8] vvtTable1LoadBins;;"L", 1, 0, 0, 1000, 0
uint16_t[SCRIPT_TABLE_8] vvtTable1RpmBins;;"RPM", 1, 0, 0, 18000, 0

int8_t[SCRIPT_TABLE_8 x SCRIPT_TABLE_8] vvtTable2;;"value", 1, 0, -125, 125, 0
uint16_t[SCRIPT_TABLE_8] vvtTable2LoadBins;;"L", 1, 0, 0, 1000, 0
uint16_t[SCRIPT_TABLE_8] vvtTable2RpmBins;;"RPM", 1, 0, 0, 18000, 0

int16_t[IGN_RPM_COUNT x IGN_LOAD_COUNT] autoscale ignitionTable;;"deg", 0.1, 0, -20, 90, 1
uint16_t[IGN_LOAD_COUNT] ignitionLoadBins;;"Load", 1, 0, 0, 1000, 0
uint16_t[IGN_RPM_COUNT] ignitionRpmBins;;"RPM",	   1, 0, 0, 18000, 0

uint16_t[FUEL_RPM_COUNT x FUEL_LOAD_COUNT] autoscale veTable;;"%", 0.1, 0, 0, 999, 1
uint16_t[FUEL_LOAD_COUNT] veLoadBins;;"kPa",	1, 0, 0, 1000, 0
uint16_t[FUEL_RPM_COUNT] veRpmBins;;"RPM",	   1, 0, 0, 18000, 0

#if LAMBDA
uint8_t[FUEL_RPM_COUNT x FUEL_LOAD_COUNT] autoscale lambdaTable;;"lambda", {1/@@PACK_MULT_LAMBDA_CFG@@}, 0, 0.6, 1.5, 2
#else
uint8_t[FUEL_RPM_COUNT x FUEL_LOAD_COUNT] autoscale lambdaTable;;"afr", {1/@@PACK_MULT_AFR_CFG@@}, 0, 0, 25, 1
#endif

! union
!	lambda_table_t lambdaTable
!	afr_table_t afrTable
! end_union

uint16_t[FUEL_LOAD_COUNT] lambdaLoadBins;;"",	1, 0, 0, 1000, 0
uint16_t[FUEL_RPM_COUNT] lambdaRpmBins;;"RPM",	  1, 0, 0, 18000, 0

float[TPS_TPS_ACCEL_TABLE x TPS_TPS_ACCEL_TABLE] tpsTpsAccelTable;When the TPS accel threshold is exceeded, the original TPS value (X axis) is compared to the new larger TPS value (Y axis) to determine the extra fuel added to the pulsewidth in milliseconds. Where the From TPS value is greater than or less than the To TPS value that cell should be 0.;"value", 1, 0, 0, 30000, 2
float[TPS_TPS_ACCEL_TABLE] tpsTpsAccelFromRpmBins;;"from",	  1, 0, 0, 30000, 2
float[TPS_TPS_ACCEL_TABLE] tpsTpsAccelToRpmBins;;"to",	  1, 0, 0, 25500, 2

int16_t[SCRIPT_TABLE_8 x SCRIPT_TABLE_8] autoscale scriptTable1;;"value", 0.01, 0, -327, 327, 2
int16_t[SCRIPT_TABLE_8] scriptTable1LoadBins;;"L", 1, 0, -32000, 32000, 0
int16_t[SCRIPT_TABLE_8] scriptTable1RpmBins;;"RPM", 1, 0, -32000, 32000, 0

int16_t[SCRIPT_TABLE_8 x SCRIPT_TABLE_8] autoscale scriptTable2;;"value", 0.01, 0, -327, 327, 2
int16_t[SCRIPT_TABLE_8] scriptTable2LoadBins;;"L", 1, 0, -32000, 32000, 0
int16_t[SCRIPT_TABLE_8] scriptTable2RpmBins;;"RPM", 1, 0, -32000, 32000, 0

int16_t[SCRIPT_TABLE_8 x SCRIPT_TABLE_8] autoscale scriptTable3;;"value", 0.01, 0, -327, 327, 2
int16_t[SCRIPT_TABLE_8] scriptTable3LoadBins;;"L", 1, 0, -32000, 32000, 0
int16_t[SCRIPT_TABLE_8] scriptTable3RpmBins;;"RPM", 1, 0, -32000, 32000, 0

int16_t[SCRIPT_TABLE_8 x SCRIPT_TABLE_8] autoscale scriptTable4;;"value", 0.01, 0, -327, 327, 2
int16_t[SCRIPT_TABLE_8] scriptTable4LoadBins;;"L", 1, 0, -32000, 32000, 0
int16_t[SCRIPT_TABLE_8] scriptTable4RpmBins;;"RPM", 1, 0, -32000, 32000, 0

#define TRIM_SIZE 4

struct cyl_trim_s
	int8_t[TRIM_SIZE x TRIM_SIZE] autoscale table;;"", 0.2, 0, -25, 25, 1
end_struct

! All ign trim tables share axes
uint16_t[TRIM_SIZE] ignTrimLoadBins;;"", 1, 0, 0, 1000, 0
uint16_t[TRIM_SIZE] ignTrimRpmBins;;"rpm", 1, 0, 0, 20000, 0
cyl_trim_s[12 iterate] ignTrims

! All fuel trim tables share axes
uint16_t[TRIM_SIZE] fuelTrimLoadBins;;"", 1, 0, 0, 1000, 0
uint16_t[TRIM_SIZE] fuelTrimRpmBins;;"rpm", 1, 0, 0, 20000, 0
cyl_trim_s[12 iterate] fuelTrims

uint16_t[CRANKING_CURVE_SIZE] autoscale crankingFuelCoefE100;;"ratio", 0.01, 0, 0, 50, 2

#define TCU_MAGIC_SIZE 8

uint8_t[TCU_MAGIC_SIZE] autoscale tcu_pcAirmassBins;;"Airmass", 0.02, 0, 0, 255, 2
uint8_t[TCU_MAGIC_SIZE] tcu_pcValsR;;"%", 1, 0, 0, 255, 0
uint8_t[TCU_MAGIC_SIZE] tcu_pcValsN;;"%", 1, 0, 0, 255, 0
uint8_t[TCU_MAGIC_SIZE] tcu_pcVals1;;"%", 1, 0, 0, 255, 0
uint8_t[TCU_MAGIC_SIZE] tcu_pcVals2;;"%", 1, 0, 0, 255, 0
uint8_t[TCU_MAGIC_SIZE] tcu_pcVals3;;"%", 1, 0, 0, 255, 0
uint8_t[TCU_MAGIC_SIZE] tcu_pcVals4;;"%", 1, 0, 0, 255, 0
uint8_t[TCU_MAGIC_SIZE] tcu_pcVals12;;"%", 1, 0, 0, 255, 0
uint8_t[TCU_MAGIC_SIZE] tcu_pcVals23;;"%", 1, 0, 0, 255, 0
uint8_t[TCU_MAGIC_SIZE] tcu_pcVals34;;"%", 1, 0, 0, 255, 0
uint8_t[TCU_MAGIC_SIZE] tcu_pcVals21;;"%", 1, 0, 0, 255, 0
uint8_t[TCU_MAGIC_SIZE] tcu_pcVals32;;"%", 1, 0, 0, 255, 0
uint8_t[TCU_MAGIC_SIZE] tcu_pcVals43;;"%", 1, 0, 0, 255, 0

uint8_t[8] tcu_tccTpsBins;;"TPS", 1, 0, 0, 255, 0
uint8_t[8] tcu_tccLockSpeed;;"MPH", 1, 0, 0, 255, 0
uint8_t[8] tcu_tccUnlockSpeed;;"MPH", 1, 0, 0, 255, 0

uint8_t[8] tcu_32SpeedBins;;"KPH", 1, 0, 0, 255, 0
uint8_t[8] tcu_32Vals;;"%", 1, 0, 0, 255, 0

int8_t[6 x 6] autoscale throttle2TrimTable;;"%", 0.1, 0, -10, 10, 1
uint8_t[6] throttle2TrimTpsBins;;"%", 1, 0, 0, 120, 0
uint8_t[6] autoscale throttle2TrimRpmBins;;"RPM", 100, 0, 0, 25000, 0

uint8_t[6 x 6] autoscale maxKnockRetardTable;;"deg", 0.25, 0, 0, 30, 2
uint8_t[6] maxKnockRetardLoadBins;;"%", 1, 0, 0, 250, 0
uint8_t[6] autoscale maxKnockRetardRpmBins;;"RPM", 100, 0, 0, 25000, 0

int16_t[4 x 4] autoscale ALSTimingRetardTable;;"deg", 0.1, 0, -720, 720, 1
uint16_t[4] alsIgnRetardLoadBins;;"TPS", 1, 0, 0, 100, 0
uint16_t[4] alsIgnRetardrpmBins;;"RPM",	   1, 0, 0, 25000, 0

int16_t[4 x 4] autoscale ALSFuelAdjustment;;"percent", 0.1, 0, 0, 500, 1
uint16_t[4] alsFuelAdjustmentLoadBins;;"TPS", 1, 0, 0, 100, 0
uint16_t[4] alsFuelAdjustmentrpmBins;;"RPM",	1, 0, 0, 25000, 0

struct blend_table_s
	int16_t[8 x 8] autoscale table;;"", 0.1, 0, -100, 100, 1
	uint16_t[8] loadBins;;"Load", 1, 0, 0, 1000, 0
	uint16_t[8] rpmBins;;"RPM", 1, 0, 0, 18000, 0

	gppwm_channel_e blendParameter
	gppwm_channel_e yAxisOverride

	int16_t[8] autoscale blendBins;;"", 0.1, 0, -1000, 1000, 1
	uint8_t[8] autoscale blendValues;;"%", 0.5, 0, 0, 100, 1
end_struct

blend_table_s[IGN_BLEND_COUNT iterate] ignBlends
blend_table_s[VE_BLEND_COUNT iterate] veBlends

uint16_t[12] autoscale throttleEstimateEffectiveAreaBins;;"%", 0.1, 0, 0, 100, 1
uint16_t[12] autoscale throttleEstimateEffectiveAreaValues;In units of g/s normalized to choked flow conditions;"g/s", 0.1, 0, 0, 6500, 1

blend_table_s[BOOST_BLEND_COUNT iterate] boostOpenLoopBlends
blend_table_s[BOOST_BLEND_COUNT iterate] boostClosedLoopBlends

uint8_t[4 x 4] autoscale lambdaMaxDeviationTable;;"lambda", 0.01, 0, 0, 1, 2
uint16_t[4] lambdaMaxDeviationLoadBins;;"", 1, 0, 0, 1000, 0
uint16_t[4] lambdaMaxDeviationRpmBins;;"RPM",  1, 0, 0, 18000, 0

uint8_t[6 x 6] injectorStagingTable;;"%", 1, 0, 0, 90, 0
uint16_t[6] injectorStagingLoadBins;;"", 1, 0, 0, 1000, 0
uint16_t[6] injectorStagingRpmBins;;"RPM",  1, 0, 0, 18000, 0

#define WWAE_TABLE_SIZE 8

int8_t[WWAE_TABLE_SIZE] wwCltBins;;"deg C", 1, 0, -40, 120, 0
uint8_t[WWAE_TABLE_SIZE] autoscale wwTauCltValues;;"", 0.01, 0, 0, 2.5, 2
uint8_t[WWAE_TABLE_SIZE] autoscale wwBetaCltValues;;"", 0.01, 0, 0, 1, 2

int8_t[WWAE_TABLE_SIZE] wwMapBins;;"kPa", 1, 0, 0, 250, 0
uint8_t[WWAE_TABLE_SIZE] autoscale wwTauMapValues;;"", 0.01, 0, 0, 2.5, 2
uint8_t[WWAE_TABLE_SIZE] autoscale wwBetaMapValues;;"", 0.01, 0, 0, 2.5, 2

uint8_t[HPFP_LOBE_PROFILE_SIZE] autoscale hpfpLobeProfileQuantityBins;;"%", 0.5, 0, 0, 100, 1
uint8_t[HPFP_LOBE_PROFILE_SIZE] autoscale hpfpLobeProfileAngle;;"deg", 0.5, 0, 0, 125, 1
uint8_t[HPFP_DEADTIME_SIZE] hpfpDeadtimeVoltsBins;;"volts", 1, 0, 0, 255, 0
uint16_t[HPFP_DEADTIME_SIZE] autoscale hpfpDeadtimeMS;;"ms", 0.001, 0, 0, 65, 3
uint16_t[HPFP_TARGET_SIZE x HPFP_TARGET_SIZE] hpfpTarget;;"kPa", 1, 0, 0, 65000, 0
uint16_t[HPFP_TARGET_SIZE] autoscale hpfpTargetLoadBins;;"load", 0.1, 0, 0, 6500, 1
uint8_t[HPFP_TARGET_SIZE] autoscale hpfpTargetRpmBins;;"RPM", 50, 0, 0, 12500, 0
int8_t[HPFP_COMPENSATION_SIZE x HPFP_COMPENSATION_SIZE] hpfpCompensation;;"%", 1, 0, -100, 100, 0
uint16_t[HPFP_COMPENSATION_SIZE] autoscale hpfpCompensationLoadBins;;"cc/lobe", 0.001, 0, 0, 65, 3
uint8_t[HPFP_COMPENSATION_SIZE] autoscale hpfpCompensationRpmBins;;"RPM", 50, 0, 0, 12500, 0

uint16_t[ENGINE_NOISE_CURVE_SIZE] knockNoiseRpmBins;;"RPM", 1, 0, 0, 30000, 0
int8_t[ENGINE_NOISE_CURVE_SIZE] autoscale knockBaseNoise;Knock sensor output knock detection threshold depending on current RPM.;"dB", 0.5, 0, -50, 10, 1

uint8_t[TPS_TPS_ACCEL_CLT_CORR_TABLE] autoscale tpsTspCorrValuesBins;;"RPM", 50, 0, 0, 17500, 0
uint8_t[TPS_TPS_ACCEL_CLT_CORR_TABLE] autoscale tpsTspCorrValues;Multiplier applied to the output of the TPS/TPS Acceleration Extra Fuel table. In general, engines may need more acceleration enrichment at lower engine speeds than higher engine speeds. A value of 2.0 multiplies the additional acceleration enrichment pulsewidth by 200%, a value of 1.0 does not modify the output.;"multiplier", 0.02, 0, 0, 5, 2

int8_t[CLT_LIMITER_CURVE_SIZE] cltRevLimitRpmBins;;"C", 1, 0, -40, 120, 0
uint16_t[CLT_LIMITER_CURVE_SIZE] cltRevLimitRpm;;"RPM", 1, 0, 0, 20000, 0

uint16_t[FUEL_LEVEL_TABLE_COUNT] autoscale fuelLevelBins;;"volt", {1/@@PACK_MULT_VOLTAGE@@}, 0, 0, 5, 3
uint8_t[FUEL_LEVEL_TABLE_COUNT] fuelLevelValues;;"%", 1, 0, 0, 100, 0

uint8_t[DWELL_CURVE_SIZE] autoscale dwellVoltageCorrVoltBins;;"volts", 0.1, 0, 0, 20, 1
uint8_t[DWELL_CURVE_SIZE] autoscale dwellVoltageCorrValues;;"multiplier", 0.02, 0, 0, 5, 2

uint8_t[8] autoscale minimumOilPressureBins;;"RPM", 100, 0, 0, 25000, 0
uint8_t[8] autoscale minimumOilPressureValues;;"kPa", 10, 0, 0, 1000, 0

uint8_t[DFCO_RPM_MAP_TABLE] autoscale dfcoMapRpmValuesBins;;"RPM", 100, 0, 0, 17500, 0
uint8_t[DFCO_RPM_MAP_TABLE] autoscale dfcoMapRpmValues;DFCO will activate when operating below this curve. Used to allow a higher threshold at low RPM where less vaccuum is generated;"MAP", 1, 0, 0, 50, 0

uint8_t[8 x 8] autoscale postCrankingEnrichTable;;"ratio", 0.02, 0, 1, 5, 2
int8_t[8] autoscale postCrankingEnrichTempBins;;"deg C", 1, 0, -40, 120, 0
uint8_t[8] postCrankingEnrichRuntimeBins;;"sec", 1, 0, 0, 180, 0 

end_struct

! Pedal Position Sensor
#define MOCK_PPS_POSITION_COMMAND "mock_pps_position"
#define MOCK_PPS_VOLTAGE_COMMAND "mock_pps_voltage"

#define ENGINE_MAKE_HONDA "Honda"
#define ENGINE_MAKE_MAZDA "Mazda"
#define ENGINE_MAKE_LADA "Lada"
#define ENGINE_MAKE_NISSAN "Nissan"
#define ENGINE_MAKE_GM "GM"
#define ENGINE_MAKE_SUBARU "Subaru"
#define ENGINE_MAKE_BMW "BMW"
#define ENGINE_MAKE_TOYOTA "Toyota"
#define ENGINE_MAKE_MERCEDES "Mercedes"
#define ENGINE_MAKE_VAG "VAG"
#define ENGINE_MAKE_Hyundai "Hyundai"

#define CMD_SET "set"
#define CMD_GET "get"
#define CMD_ENGINESNIFFERRPMTHRESHOLD "engineSnifferRpmThreshold"
#define CMD_MIL_BENCH "milbench"
#define CMD_FUEL_BENCH "fuelbench"
#define CMD_FUEL_PUMP_BENCH "fuelpumpbench"
#define CMD_IDLE_BENCH "idlebench"
#define CMD_SPARK_BENCH "sparkbench"
#define CMD_STARTER_BENCH "starterbench"
#define CMD_HPFP_BENCH "hpfpbench"
#define CMD_AC_RELAY_BENCH "acrelaybench"
#define CMD_FAN_BENCH "fanbench"
#define CMD_FAN2_BENCH "fan2bench"
#define CMD_PINS "pins"
#define CMD_ETB_DUTY "set_etb_duty"
#define CMD_SELF_STIMULATION "self_stimulation"
#define CMD_EXTERNAL_STIMULATION "ext_stimulation"
#define CMD_RPM "rpm"
#define CMD_VSS_PIN "vss_pin"
#define CMD_TRIGGER_PIN "set_trigger_input_pin"
#define CMD_LOGIC_PIN "set_logic_input_pin"
#define CMD_ALTERNATOR_PIN "set_alternator_pin"
#define CMD_IDLE_PIN "set_idle_pin"
#define CMD_BOOST_PIN "set_boost_pin"
#define CMD_TRIGGER_SIMULATOR_PIN "set_trigger_simulator_pin"
#define CMD_IGNITION_PIN "set_ignition_pin"

#define CMD_RESET_ENGINE_SNIFFER "reset_engine_chart"
#define CMD_FUNCTIONAL_TEST_MODE "test_mode"

#define CMD_ECU_UNLOCK "unlock"
#define CMD_ENGINE_TYPE "engine_type"
#define CMD_INJECTION "injection"
#define CMD_IGNITION "ignition"
#define CMD_PWM "pwm"
#define CMD_TRIGGERINFO "triggerinfo"
#define CMD_WRITECONFIG "writeconfig"
#define CMD_BURNCONFIG "burnconfig"
#define CMD_DATE "date"
#define CMD_REBOOT "reboot"
#define CMD_REBOOT_DFU "reboot_dfu"
#define CMD_REBOOT_OPENBLT "reboot_openblt"
#define CMD_ENABLE "enable"
#define CMD_DISABLE "disable"
#define CMD_TRIGGER_HW_INPUT "trigger_hw_input"

#define PROTOCOL_MSG "msg"
#define PROTOCOL_HELLO_PREFIX "***"

#define TS_RESPONSE_UNDERRUN 0x80
#define TS_RESPONSE_CRC_FAILURE 0x82
#define TS_RESPONSE_UNRECOGNIZED_COMMAND 0x83
#define TS_RESPONSE_OUT_OF_RANGE 0x84
#define TS_RESPONSE_FRAMING_ERROR 0x8D

! we need 3 seconds on single-bank to survive write-to-flash reconnect
! dual-bank devices can go with 300 for better TS reconnect experience
#define TS_BLOCK_READ_TIMEOUT 3000

#define MLQ_HEADER_SIZE 24
#define MLQ_FIELD_HEADER_SIZE 89

#define PROTOCOL_OUTPIN "outpin"
#define PROTOCOL_ANALOG_CHART "analog_chart"
#define PROTOCOL_ENGINE_SNIFFER "wave_chart"
#define PROTOCOL_VERSION_TAG "fomeVersion"
#define PROTOCOL_TEST_RESPONSE_TAG "ts_p_alive"
#define PROTOCOL_SIGNATURE_PREFIX "rusEFI "

! Engine Sniffer Protocol
#define PROTOCOL_ES_DOWN "d"
#define PROTOCOL_ES_UP "u"
#define TOP_DEAD_CENTER_MESSAGE "r"

! Engine Sniffer channel names
#define PROTOCOL_CRANK1 "t1"
#define PROTOCOL_CRANK2 "t2"

#define PROTOCOL_VVT1_NAME "VVT1"
#define PROTOCOL_VVT2_NAME "VVT2"
#define PROTOCOL_VVT3_NAME "VVT3"
#define PROTOCOL_VVT4_NAME "VVT4"
#define PROTOCOL_HPFP_NAME "hpfp"

#define PROTOCOL_WA_CHANNEL_1 "input1"
#define PROTOCOL_WA_CHANNEL_2 "input2"
#define PROTOCOL_WA_CHANNEL_3 "input3"
#define PROTOCOL_WA_CHANNEL_4 "input4"


#define TS_PROTOCOL "001"
! These commands are used by TunerStudio and the FOME console
! 0x4F ochGetCommand
#define TS_OUTPUT_COMMAND 'O'
! 0x53 queryCommand
#define TS_HELLO_COMMAND 'S'
! todo: replace all usages of TS_HELLO_COMMAND with TS_QUERY_COMMAND
! TS auto-detect depends on well-known queryCommand value 'Q'
#define TS_QUERY_COMMAND 'Q'
! 0x6B 107
#define TS_CRC_CHECK_COMMAND 'k'
! 0x52 82
#define TS_READ_COMMAND 'R'
! 0x47
#define TS_GET_TEXT 'G'
! 0x45
#define TS_EXECUTE 'E'
#define TS_ONLINE_PROTOCOL 'z'
#define TS_QUERY_BOOTLOADER 'L'

#define TS_QUERY_BOOTLOADER_NONE 0
#define TS_QUERY_BOOTLOADER_OPENBLT 1

! Performance tracing
#define TS_PERF_TRACE_BEGIN '_'
#define TS_PERF_TRACE_GET_BUFFER 'b'

! 0x50 80
#define TS_PAGE_COMMAND 'P'
! 0x46
#define TS_COMMAND_F 'F'
#define TS_GET_PROTOCOL_VERSION_COMMAND_F 'F'
! versionInfo 0x56 86
#define TS_GET_FIRMWARE_VERSION 'V'
! returns getFirmwareError(), works together with ind_hasFatalError
#define TS_GET_CONFIG_ERROR 'e'


! 0x57 pageValueWrite
#define TS_SINGLE_WRITE_COMMAND 'W'
! 0x43 pageChunkWrite
#define TS_CHUNK_WRITE_COMMAND 'C'
! 0x42 burnCommand
#define TS_BURN_COMMAND 'B'
! 0x77
#define TS_IO_TEST_COMMAND 'Z'

#define TS_RESPONSE_OK 0
#define TS_RESPONSE_BURN_OK 4

! Engine Sniffer time stamp unit, in microseconds
#define ENGINE_SNIFFER_UNIT_US 10

! High speed logger commands
#define TS_SET_LOGGER_SWITCH  'l'

#define TS_COMPOSITE_ENABLE 1
#define TS_COMPOSITE_DISABLE 2
#define TS_COMPOSITE_READ 3

#define TS_TRIGGER_SCOPE_ENABLE 4
#define TS_TRIGGER_SCOPE_DISABLE 5
#define TS_TRIGGER_SCOPE_READ 6

! Generic channel names, your board may want to override these
#define TS_TRIGGER_SCOPE_CHANNEL_1_NAME "Channel 1"
#define TS_TRIGGER_SCOPE_CHANNEL_2_NAME "Channel 2"

#define PROTOCOL_COIL1_SHORT_NAME "c1"
#define PROTOCOL_INJ1_SHORT_NAME "i1"
#define PROTOCOL_INJ1_STAGE2_SHORT_NAME "j1"

! some board files override this value using prepend file
#define ts_show_vr_threshold_all true
#define ts_show_vr_threshold_2 true
#define ts_show_main_relay true
#define ts_show_main_relay_microRusEFI_message false
#define ts_show_etb true
#define ts_show_etb_pins true
#define ts_show_full_pinout true
#define ts_show_egt true
#define ts_show_analog_divider true
#define ts_show_spi true
#define ts_show_sd_card true
#define ts_show_can_pins true
#define ts_show_vbatt true
#define ts_show_clt_iat_pullup true
#define ts_show_tunerstudio_port true
#define ts_show_trigger_comparator false
#define ts_show_auxserial_pins true
#define ts_show_can2 true
#define ts_show_software_knock false
#define ts_show_hardware_simulator true
#define ts_show_sd_pins true
#define ts_show_injectionPinMode true
#define ts_show_ignitionPinMode true
#define ts_show_inj_fault false
#define ts_show_ign_fault false
#define ts_show_trigger_pins true
#define ts_show_cam_inputs true
#define ts_show_injector_pins true
#define ts_show_injection_mode true
#define ts_show_ignition_pins true
#define ts_show_ignition_mode true
#define ts_show_energySystems true
#define ts_show_acSettings true
#define ts_show_idle true
#define ts_show_boost true
#define ts_show_vvt true
#define ts_show_pedal true
#define ts_show_maf true

! we need to improve this further - at the moment we need too many boards to prepend 'false'
#define show_test_presets true
#define show_Frankenso_presets true

#define CAN_ECU_SERIAL_RX_ID 0x100
#define CAN_ECU_SERIAL_TX_ID 0x102

#define CAN_ECU_HW_META 0xAB1234
