package com.rusefi.ldmp;

import com.devexperts.logging.Logging;
import com.rusefi.EnumToString;
import com.rusefi.InvokeReader;
import com.rusefi.RusefiParseErrorStrategy;
import com.rusefi.newparse.ParseState;
import com.rusefi.newparse.outputs.*;
import com.rusefi.newparse.outputs.PrintStreamAlwaysUnix;
import com.rusefi.newparse.parsing.Definition;
import org.yaml.snakeyaml.Yaml;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;

public class LiveDataProcessor {
    private final static Logging log = Logging.getLogging(LiveDataProcessor.class);

    private final static String header = "// generated by gen_live_documentation.sh / LiveDataProcessor.java\n";

    private final static String enumContentFileName = "generated/live_data_ids.h";

    private final static String tsOutputsDestination = "generated/";

    private final StringBuilder enumContent = new StringBuilder(header +
            "#pragma once\n" +
            "\n" +
            "typedef enum {\n");

    private final StringBuilder baseAddressCHeader = new StringBuilder();

    private final StringBuilder fragmentsContent = new StringBuilder(header);

    private final String extraPrepend = System.getProperty("LiveDataProcessor.extra_prepend");

    private final ArrayList<String> inputFiles = new ArrayList<>();
    private final ArrayList<String> outputFiles = new ArrayList<>();

    public static void main(String[] args) throws IOException {
        if (args.length < 1) {
            System.err.println("Usage: LiveDataProcessor <yaml_file> [-makefileDep <dep_file>] [-stampFile <stamp_file>]");
            System.exit(-1);
        }

        // ensure outputs directory exists - it's gitignored
        Files.createDirectories(Paths.get(tsOutputsDestination));

        String yamlFileName = args[0];
        String makefileDepsDestination = null;
        String stampFile = null;

        // Parse optional arguments
        for (int i = 1; i < args.length - 1; i += 2) {
            if ("-makefileDep".equals(args[i])) {
                makefileDepsDestination = args[i + 1];
            } else if ("-stampFile".equals(args[i])) {
                stampFile = args[i + 1];
            }
        }

        Yaml yaml = new Yaml();
        Map<String, Object> data = yaml.load(new FileReader(yamlFileName));

        LiveDataProcessor liveDataProcessor = new LiveDataProcessor();
        liveDataProcessor.inputFiles.add(yamlFileName);

        int sensorTsPosition = liveDataProcessor.handleYaml(data);
        liveDataProcessor.writeFiles();

        log.info("TS_TOTAL_OUTPUT_SIZE=" + sensorTsPosition);
        String totalLiveDataFile = "generated/total_live_data_generated.h";
        try (FileWriter fw = new FileWriter(totalLiveDataFile)) {
            fw.write(header);
            fw.write("#define TS_TOTAL_OUTPUT_SIZE " + sensorTsPosition);
        }
        liveDataProcessor.outputFiles.add(totalLiveDataFile);

        if (makefileDepsDestination != null) {
            liveDataProcessor.writeMakefileDependencyFile(makefileDepsDestination, stampFile);
        }
    }

    interface EntryHandler {
        void onEntry(String name, String javaName, String folder, String prepend, String[] outputNames, String constexpr, String conditional, Boolean isPtr) throws IOException;
    }

    private int handleYaml(Map<String, Object> data) throws IOException {
        OutputChannelWriter outputChannelWriter = new OutputChannelWriter(
            tsOutputsDestination + File.separator + "/output_channels.ini",
            tsOutputsDestination + File.separator + "/data_logs.ini"
        );

        SdLogWriter sdLogWriter = new SdLogWriter("generated/log_fields_generated.h");

        OutputLookupWriter outputLookupWriter = new OutputLookupWriter("generated/output_lookup_generated.cpp", "getOutputValueByName");

        EntryHandler handler = (name, javaName, folder, prepend, outputNames, constexpr, conditional, isPtr) -> {
            int startingPosition = outputChannelWriter.getSize();
            log.info("Starting " + name + " at " + startingPosition + " with [" + conditional + "]");

            baseAddressCHeader.append("#define ").append(name.toUpperCase()).append("_BASE_ADDRESS ").append(startingPosition).append("\n");

            String cHeaderDestination = folder + File.separator + name + "_generated.h";
            String definitionFile = folder + File.separator + name + ".txt";

            // Track input files for dependency generation
            inputFiles.add(definitionFile);
            if (prepend != null && !prepend.isEmpty()) {
                inputFiles.add(prepend);
            }

            {
                ParseState parseState = new ParseState();

                parseState.setDefinitionPolicy(Definition.OverwritePolicy.NotAllowed);

                if (prepend != null && !prepend.isEmpty()) {
                    RusefiParseErrorStrategy.parseDefinitionFile(parseState.getListener(), prepend);
                }

                RusefiParseErrorStrategy.parseDefinitionFile(parseState.getListener(), definitionFile);

                CStructWriter cStructs = new CStructWriter();
                cStructs.writeCStructs(parseState, cHeaderDestination);

                if (javaName != null) {
                    JavaFieldsWriter javaWriter = new JavaFieldsWriter("../java_console/generated/src/main/java/com/rusefi/config/generated/" + javaName, outputChannelWriter.getSize());
                    javaWriter.writeDefinitions(parseState.getDefinitions());
                    javaWriter.writeFields(parseState);
                    javaWriter.finish();
                }

                if (outputNames.length == 0) {
                    outputChannelWriter.writeOutputChannels(parseState, null);
                } else {
                    for (String outputName : outputNames) {
                        outputChannelWriter.writeOutputChannels(parseState, outputName);
                    }
                }

                if (constexpr != null) {
                    sdLogWriter.writeSdLogs(parseState, constexpr + (isPtr ? "->" : "."));

                    outputLookupWriter.addOutputLookups(parseState, constexpr + (isPtr ? "->" : "."), conditional);
                }
            }

            log.info("Done with " + name + " at " + outputChannelWriter.getSize());
        };


        ArrayList<LinkedHashMap<String, Object>> liveDocs = (ArrayList<LinkedHashMap<String, Object>>) data.get("Usages");

        for (LinkedHashMap<String, Object> entry : liveDocs) {
            String name = (String) entry.get("name");
            String java = (String) entry.get("java");
            String folder = (String) entry.get("folder");
            String prepend = (String) entry.get("prepend");
            String constexpr = (String) entry.get("constexpr");
            String conditional = (String) entry.get("conditional_compilation");
            Boolean isPtr = (Boolean) entry.get("isPtr");
            // Defaults to false if not specified
            isPtr = isPtr != null && isPtr;

            Object outputNames = entry.get("output_name");

            String[] outputNamesArr;
            if (outputNames == null) {
                outputNamesArr = new String[0];
            } else if (outputNames instanceof String) {
                outputNamesArr = new String[1];
                outputNamesArr[0] = (String) outputNames;
            } else {
                ArrayList<String> nameList = (ArrayList<String>) outputNames;
                outputNamesArr = new String[nameList.size()];
                nameList.toArray(outputNamesArr);
            }

            handler.onEntry(name, java, folder, prepend, outputNamesArr, constexpr, conditional, isPtr);

            String enumName = "LDS_" + name;
            String type = name + "_s"; // convention
            enumContent.append(enumName + ",\n");

            if (outputNamesArr.length <= 1) {
                fragmentsContent
                        .append("decl_frag<")
                        .append(type)
                        .append(">{},\n");
            } else {
                for (int i = 0; i < outputNamesArr.length; i++) {
                    fragmentsContent
                            .append("decl_frag<")
                            .append(type)
                            .append(", ")
                            .append(i)
                            .append(">{},\t// ")
                            .append(outputNamesArr[i])
                            .append("\n");
                }
            }
        }
        enumContent.append("} live_data_e;\n");

        sdLogWriter.endFile();
        outputLookupWriter.endFile();

        return outputChannelWriter.getSize();
    }

    private void writeFiles() throws IOException {
        try (FileWriter fw = new FileWriter(enumContentFileName)) {
            fw.write(enumContent.toString());
            fw.write(baseAddressCHeader.toString());
        }
        outputFiles.add(enumContentFileName);

        String fragmentsFile = "generated/live_data_fragments.h";
        try (FileWriter fw = new FileWriter(fragmentsFile)) {
            fw.write(fragmentsContent.toString());
        }
        outputFiles.add(fragmentsFile);

        String outputPath = "../java_console/io/src/main/java/com/rusefi/enums";
        InvokeReader request = new InvokeReader(outputPath, Collections.singletonList(enumContentFileName));
        new EnumToString().handleRequest(request);
    }

    private void writeMakefileDependencyFile(String makefileDepsDestination, String stampFile) throws IOException {
        // Also add the outputs generated by SdLogWriter and OutputLookupWriter
        outputFiles.add("generated/log_fields_generated.h");
        outputFiles.add("generated/output_lookup_generated.cpp");

        Path path = Paths.get(makefileDepsDestination);
        Files.createDirectories(path.getParent());
        PrintStream f = new PrintStreamAlwaysUnix(Files.newOutputStream(path));

        // Use stamp file as target if provided, otherwise use the first output file
        String target = stampFile != null ? stampFile : outputFiles.get(0);
        f.print(target + ": ");
        for (String input : inputFiles) {
            f.print(input);
            f.print(" ");
        }
        f.println();

        // Inform make of all inputs, these have no dependencies
        for (String input : inputFiles) {
            f.println(input + ":");
            f.println();
        }

        f.close();

        // Write the outputs .mk file for make to know about generated files
        writeOutputsMkFile(path.getParent());
    }

    private void writeOutputsMkFile(Path depDir) throws IOException {
        Path mkPath = depDir.resolve("generated_live_data_outputs.mk");
        PrintStream f = new PrintStreamAlwaysUnix(Files.newOutputStream(mkPath));

        f.print("GENERATED_FILES +=");
        for (String output : outputFiles) {
            f.print(" \\\n\t" + output);
        }
        f.println();

        f.close();
    }
}
